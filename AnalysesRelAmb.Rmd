---
Title:  "Analyses RelAmb"
Author: "Thomas Verliefde"
Date:   "2018-12-18""
Output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, options}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())

lapply(
  c("plyr","dplyr","tidyr","ggplot2","readxl","readr","magrittr"),
  require,
  character.only = T
)
```

#############################
# Importing & Cleaning Data #
#############################

Make sure the relevant datafiles (Data_RelAmb.zip and BAWL-R.xls) are in the working directory.

```{r BAWL-R.xls, options}

bawl <- "BAWL-R.xls" %>% read_excel %>%
  mutate(
    WORD_CLASS = recode(
      WORD_CLASS,
      "N" = "NOUN",
      "V" = "VERB",
      "A" = "ADJ"
    )
  )


```

```{r Data_RelAmb.zip, message=FALSE}

temp <- tempdir()
df_raw <- "Data_RelAmb.zip" %>% {
  ldply(
    .data = unzip(.,list=T) %>% filter(grepl("(.csv)$",.$Name)) %$% Name,
    .fun = function(x) unzip(.,files=x,exdir=temp) %>% read_csv
  )
}
rm(temp)

```


This part cleans the data up a lot, and puts it in an useable long format.

A few variables are dropped, as they are not crucial for the current investigations.
The data for each trial (both practice and experiment) is put in long format.
The data for each significant other is put in long format.
The information about block(practice/experiment), trialnr, and descriptives (Answer,Prime, primeType, Target, targetType, RT).
Descriptives is spread out again, to have columns for each.
Some variables are renamed.
Some variables are mutated:
  Many are transformed to strings or numericals
  primeType & targetType get clear non-numerical labels
  primeValence is created to reflect the valence of the primes (regardless of nouns or others)
  Condition shows congruent or incongruent trials
  Correct indicates whether the target was correctly classified
  Inclusion sets whether or not the trial should be included
    Note: we should still implement exclusion of low acc participants # tried implementing, not yet ready
  LogRT is a simple transformation of RT to it's natural logarithm.

```{r cleaning & gathering, options}

df <- df_raw %>% 
  select(
    -c(practicePrimes,practiceTrials,experimentPrimes,experimentTrials,hostName)
  ) %>%
  gather(
    "fullTrials",
    "trialsOutput",
    matches("^([a-z])+_(\\d)+_([a-z])+$") # This regex matches things with structure: abcd*_123*_abcd*
  ) %>%
  gather(
    "fullOthers",
    "otherOutput",
    matches("^(other)(Pos|Neg)(1|2)") # This regex matches: otherPos1_*, otherPos2_*¨, otherNeg1_*, or otherNeg2_*
  ) %>%
  separate(
    fullTrials,
    c("Block","Trial","Desc"),
    sep = "_"
  ) %>%
  spread(
    key = Desc, value = trialsOutput
  ) %>%
  separate(
    fullOthers,
    c("SO","Desc"),
    sep = "_",
    extra = "merge",
    fill = "right"
  ) %>%
  mutate(
    Desc = Desc %>% replace_na("otherNames") # alternatively, we could use coalesce.
  ) %>%
  spread(
    key = Desc, value = otherOutput
  ) %>%
  rename(
    Answer = answer,
    Prime = prime,
    primeType = primeCat,
    Target = target,
    targetType = targetCat,
    RT = time
  ) %>%
  mutate_at(
    vars(RT,Age,matches("^(time)")),
    as.numeric
  ) %>%
  mutate_at(
    vars(Subject,Trial),
    as.character
  ) %>%
  filter(Block == "experiment") %>% # drop all practice trials
  group_by(Subject) %>%
  mutate(
    Gender = recode(
      Gender,
      "männlich" = "male",
      "weiblich" = "female"
    ),
    Language = recode(
      Language,
      "Deutsch" = "germanLang",
      "Sonstiges" = "otherLang"
    ),
    Handedness = recode(
      Handedness,
      "rechts" = "rightHand",
      "links" = "leftHand",
      "beide" = "bothHands"
    ),
    primeType = recode(
      primeType,
      `0`= "nounPos",
      `1`= "nounNeg",
      `2`= "otherPos",
      `3`= "otherNeg",
      `4`= "letterStr"
    ),
    targetType = recode(
      targetType,
      `0` = "adjPos",
      `1` = "adjNeg"
    ),
    primeValence = case_when(
      grepl("Pos$",primeType) ~ "Pos",
      grepl("Neg$",primeType) ~ "Neg",
      TRUE ~ "Neutral"
    ),
    Condition = case_when(
      primeValence == "Pos" & targetType == "adjPos" ~ "Congruent",
      primeValence == "Neg" & targetType == "adjNeg" ~ "Congruent",
      TRUE ~ "Incongruent"
    ),
    Correct = case_when(
      Key == "Apos" & targetType == "adjPos" & Answer == "A" ~ TRUE,
      Key == "Apos" & targetType == "adjNeg" & Answer == "L" ~ TRUE,
      Key == "Aneg" & targetType == "adjNeg" & Answer == "A" ~ TRUE,
      Key == "Aneg" & targetType == "adjPos" & Answer == "L" ~ TRUE,
      TRUE ~ FALSE
    ),
    Accuracy = mean(Correct), # Because we grouped by subject, these means are computed by subject
    baseInclusion = Correct & RT > 300 & RT < 3000,
    subjInclusion = 1 - mean(baseInclusion) < 0.83,
      # If we have to exclude more than 83% of the trials of a single participant,
      #  then this participant will be excluded entirely.
    Inclusion = baseInclusion & subjInclusion,
    logRT = log(RT)
  ) %>%
  ungroup %>%
  arrange(Subject)

```

################
# Demographics #
################

```{r Inclusions, options}

df %$% equals(Inclusion,baseInclusion) %>% all

```

```{r Gender; Language; & Handedness, options}

df %>% filter(Subject %>% duplicated %>% not & subjInclusion) %>% {
  bind_rows(
    count(., "Var" = "Total"),
    count(., "Var" = Gender),
    count(., "Var" = Language),
    count(., "Var" = Handedness)
  )
} %>% mutate(
  "%" = extract2(.,1,"n") %>%
    divide_by(n,.) %>%
    multiply_by(100) %>%
    signif(4)
)


```

```{r Age; Accuracy; & Time, options}

df %>% filter(Subject %>% duplicated %>% not & subjInclusion) %>% 
  summarize_at(
    vars(Age,Accuracy,timeExperiment,timeExperiment,timeTotal),
    .funs = funs(mean,sd,.args = list(na.rm=T))
  )






```

