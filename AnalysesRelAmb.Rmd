---
Author: Thomas Verliefde
Date: '2019-06-05'
Output: html_document
Title: Analyses RelAmb
editor_options:
  chunk_output_type: console
version: '1.32'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
load("20190515.RData")

# save.image("20190515.RData")
```

As usual, I should check which packages are actually used..

```{r libraries, include=FALSE}
lapply(
  c("plyr","dplyr","tidyr","ggplot2","readxl","readr","lme4","afex","lmerTest","emmeans",
    "pbkrtest","purrr","magrittr","cowplot","parallel"),
  require,
  character.only = T
)
```

There exists a package to easily create comparison brackets for ggplot, but I cannot manage to install it.
As such, I have copied the relevant function here for my use.
The original directory, and relevant information

#############################
# Importing & Cleaning Data 
#############################

Make sure the relevant datafile (Data_RelAmb.zip) is in the working directory.

```{r RAW Data_RelAmb.zip, include=FALSE}

temp <- tempdir()
df_raw <- "Data_RelAmb.zip" %>% {
  ldply(
    .data = unzip(.,list=T) %>% # unzip the 
      filter(grepl("(.csv)$",.$Name)) %>% # Ignore any file/folder that is not a .csv file
      arrange(Name %>% desc) %$% Name, # Returns a 'list' containing the relevant .csv filenames
    .fun = function(x) unzip(.,files=x,exdir=temp) %>% read_csv
  )
}
rm(temp)

```

```{r TIME Data_RelAmb.zip, include=FALSE}

temp <- tempdir()
df_rawTime <- "Data_RelAmb.zip" %>% {
  ldply(
    .data = unzip(.,list=T) %>% # unzip the 
      filter(grepl("(.csv)$",.$Name)) %>% # Ignore any file/folder that is not a .csv file
      arrange(Name %>% desc) %$% Name, # Returns a 'list' containing the relevant .csv filenames
    .fun = function(x) unzip(.,files=x,exdir=temp) %>%
      read_csv(col_names=FALSE,skip=1) %>% select(1,(dim(.)[2]-12):dim(.)[2])
  ) %>% select(sort(current_vars())) %>% {
    bind_cols(
      filter(.,X756 %>% is.na) %>% select(-X756) %>% t %>% as_tibble,
      filter(.,X769 %>% is.na) %>% select(-X769) %>% t %>% as_tibble
    ) } %>% t %>% as_tibble %>% select(-14) %>% mutate_at(vars(-1),as.numeric) %>%
      mutate_at(vars(-1),function(x) format(x,scientific=FALSE)) %>%
    mutate_at(vars(seq(3,13,2)), function(x) gsub("( *)(\\d+)",".\\2",x)) %>%
    mutate_all(as.numeric) %$% 
      bind_cols(
        select(.,V1),
        list(extract(.,seq(2,12,2)),extract(.,seq(3,13,2))) %>% pmap(add) %>% as_tibble
      ) %>%
    rename(
      Subject = V1,
      timeOther = V2,
      timePractice = V4,
      timeExperiment = V6,
      timeExplicit = V8,
      timeDemographics = V10,
      timeTotal = V12
    )
}
rm(temp)

```

The following part cleans the data, and puts it in a long format.

A few variables are dropped, as they are not of interest for the current investigations.
The Primes/Trials variables are a list with all the primes and trials used
The data for each trial (both practice and experiment) is put in long format.
The data for each significant other is put in long format.
The information about block(practice/experiment), trialnr, and descriptives (Answer,Prime, primeType, Target, targetType, RT).
Descriptives is spread out again, to have columns for each.
Some variables are renamed.
Some variables are mutated:
  Many are transformed to strings or numericals
  primeType & targetType get clear non-numerical labels
  primeValence is created to reflect the valence of the primes (regardless of nouns or others)
  Condition shows congruent or incongruent trials (or base, for neutral stimuli)
  Correct indicates whether the target was correctly classified
  Inclusion sets whether or not the trial should be included
  LogRT is a simple transformation of RT to it's natural logarithm.

```{r wrangling, options}

df <- df_raw %>% 
  select(
    -c(practicePrimes,practiceTrials,experimentPrimes,experimentTrials,timeOther:dim(.)[2])
  ) %>%
  gather(
    "fullTrials",
    "trialsOutput",
    matches("^([a-z])+_(\\d)+_([a-z])+$") # This regex matches things with structure: abcd*_123*_abcd*
  ) %>%
  gather(
    "fullOthers",
    "otherOutput",
    matches("^(other)(Pos|Neg)(1|2)") # This regex matches: otherPos1*, otherPos2*¨, otherNeg1*, or otherNeg2*
  ) %>%
  separate(
    fullTrials,
    c("Block","Trial","Desc"),
    sep = "_"
  ) %>%
  spread(
    key = Desc, value = trialsOutput
  ) %>%
  separate(
    fullOthers,
    c("otherValence","Desc"),
    sep = "_",
    extra = "merge",
    fill = "right"
  ) %>% # Note, otherValence is repeated over trials
  mutate(
    Desc = Desc %>% replace_na("otherNames") # alternatively, we could use coalesce.
  ) %>%
  spread(
    key = Desc, value = otherOutput
  ) %>%
 gather(
    "otherDir",
    "valDir",
    matches("^(Dir_)")
  ) %>%
  gather(
    "otherSRI",
    "valSRI",
    matches("^(SRI_)")
  ) %>%
  mutate_at(
    vars(otherDir,otherSRI),
    funs(gsub("(^.{4})|(\\d)","",.))
  ) %>%
  separate(
    otherSRI,
    c("SRIValence"),
    sep = "_",
    extra = "drop",
    remove=FALSE
  ) %>%
  rename(
    Answer = answer,
    Prime = prime,
    primeType = primeCat,
    Target = target,
    targetType = targetCat,
    otherNum = Num,
    otherRel = Rel,
    RT = time
  ) %>%
  mutate_at(
    vars(Subject,Trial,RT,Age,otherNum,valDir,valSRI),
    as.numeric
  ) %>%
  group_by(Subject,Block) %>%
  mutate(
    Gender = recode(
      Gender,
      "männlich" = "male",
      "weiblich" = "female"
    ),
    Language = recode(
      Language,
      "Deutsch" = "germanLang",
      "Sonstiges" = "otherLang"
    ),
    Handedness = recode(
      Handedness,
      "rechts" = "rightHand",
      "links" = "leftHand",
      "beide" = "bothHands"
    ),
    primeType = recode(
      primeType,
      `0`= "nounPos",
      `1`= "nounNeg",
      `2`= "otherPos",
      `3`= "otherNeg",
      `4`= "letterStr"
    ) %>% as.factor,
    targetType = recode(
      targetType,
      `0` = "adjPos",
      `1` = "adjNeg"
    ),
    primeValence = case_when(
      grepl("Pos$",primeType) ~ "Pos",
      grepl("Neg$",primeType) ~ "Neg",
      TRUE ~ "Base"
    ) %>% as.factor,
    SRIValence = recode(
      SRIValence,
      "Pos" = "Helpful",
      "Neg" = "Upsetting"
    ),
    primeSource = gsub("^(noun|other|letter)(Pos|Neg|Str)$","\\1",primeType) %>% as.factor,
    otherValence2 = gsub("^(other)(Pos|Neg)(\\d)$","\\2",otherValence),
    Condition = case_when(
      primeValence == "Pos" & targetType == "adjPos" ~ "Congruent",
      primeValence == "Neg" & targetType == "adjNeg" ~ "Congruent",
      primeValence == "Base" ~ "Base",
      TRUE ~ "Incongruent"
    ) %>% as.factor,
    Correct = case_when(
      Key == "Apos" & targetType == "adjPos" & Answer == "A" ~ TRUE,
      Key == "Apos" & targetType == "adjNeg" & Answer == "L" ~ TRUE,
      Key == "Aneg" & targetType == "adjNeg" & Answer == "A" ~ TRUE,
      Key == "Aneg" & targetType == "adjPos" & Answer == "L" ~ TRUE,
      TRUE ~ FALSE),
    Accuracy = mean(Correct), # Because we grouped by subject, these means are computed by subject and block
    # speedInclusion = (RT >= 300 & RT <= 3000), # Trials with latencies < 300 and > 3000 were excluded
    # accInclusion = (1 - mean(speedInclusion)) < 0.83,
    #   # If we have to exclude more than 83% of the trials of a single participant,
    #   #  then this participant will be excluded entirely.
    # nameExclusion = (Subject == 8 | Subject == 72),
    # # These two participants did not follow instructions, as they did not provide sufficient 
    # #  and actual names for SOs as they were instructed to do.
    # # Specifically, one participant provided us with 'Niemanden' (nobody in German),
    # #  the other participant provided weird nicknames, not proper names.
    # subjExclusion = not(accInclusion) | nameExclusion,
    # Exclusion = not(speedInclusion) & not(accInclusion) & nameExclusion,
    # Inclusion = Correct & not(Exclusion),
    logRT = log(RT)
  ) %>% 
  left_join(
      group_by(.,Subject,otherValence,SRIValence,otherValence2) %>%
        summarise(AvgSRI = mean(valSRI)) %>%
        spread(SRIValence,AvgSRI) %>%
        mutate(
          catSRI = case_when(
            Helpful  > 1 & Upsetting == 1 ~ "supportive",
            Helpful  > 1 & Upsetting  > 1 ~ "ambivalent",
            Helpful == 1 & Upsetting  > 1 ~ "aversive",
            Helpful == 1 & Upsetting == 1 ~ "indifferent",
            TRUE ~ NA_character_
          ),
          #         The SRI was developed by Campo and colleagues (2009).
          # They determined categories of network ties:
          # * supportive  ->  >1 on helpful, =1 on upsetting
          # * ambivalent  ->  >1 on helpful, >1 on upsetting
          # * aversive    ->  =1 on helpful, >1 on upsetting
          # * indifferent ->  =1 on helpful, =1 on upsetting
          # 
          # The authors further mention also using a cut-off at 3 rather than 1.
          catSRI_ext = case_when(
            Helpful >= 3 & Upsetting <  3 ~ "supportive",
            Helpful >= 3 & Upsetting >= 3 ~ "ambivalent",
            Helpful <  3 & Upsetting >= 3 ~ "aversive",
            Helpful <  3 & Upsetting <  3 ~ "indifferent",
            TRUE ~ NA_character_
          )
        ) %>% ungroup %>% select(Subject,otherValence,catSRI,catSRI_ext),
      by=c("Subject","otherValence")
  ) %>%
  ungroup %>%
  spread(otherDir,valDir) %>%
  mutate(
    Griff = ((Pos + Neg) / 2) - abs(Pos - Neg),
    catGriff = case_when(
      Griff > 0 ~ "Ambivalent",
      Griff < 0 ~ "Univalent",
      TRUE ~ "Indifferent"
      ),
    catGriff_ext = case_when(
      Griff > sd(Griff) ~ "Ambivalent",
      Griff < -sd(Griff) ~ "Univalent",
      TRUE ~ "Indifferent"
      ),
    zGriff = scale(Griff),
    zFelt = scale(Amb)
    ) %>%
  rename(Felt = Amb) %>%
  gather("otherDir","valDir",Pos,Neg,Felt,Griff,zGriff,zFelt) %>%
  mutate(
  speedInclusion = (RT >= 300 & RT <= 3000), # Trials with latencies < 300 and > 3000 were excluded
  accInclusion = (1 - mean(speedInclusion & Correct)) < 0.83,
  # If we have to exclude more than 83% of the trials of a single participant,
  #  then this participant will be excluded entirely.
  nameExclusion = (Subject %in% c(8,72)),
  # These participants did not follow instructions, as they did not provide sufficient 
  #  and actual names for SOs as they were instructed to do.
  # Specifically, one participant provided us with 'Niemanden' (nobody in German),
  #  the other participant provided weird nicknames, not proper names.
  # valExclusion = (Subject %in% c(34,58)),
  # These participants did not follow instructions, as they did not provide positive and negative SOs.
  # They provided 4 positive participants (derived from their direct measures), instead of 2 positive and 2 negative.
  instrExclusion = nameExclusion, # | valExclusion,
  subjExclusion = not(accInclusion) | instrExclusion,
  trialInclusion = speedInclusion & Correct,
  Inclusion = trialInclusion & not(subjExclusion)
  ) %>%
  arrange(Subject)

```

This part creates a few subdataframes, to keep overview and reduce the amount of replicated rows.
[over 666.000 observations in "df" due to multiple "gatherings"]

```{r sub-dataframes, options}

df_subj <- df %>% filter(Block == "experiment") %>%
  select(
    Subject,Age,Gender,Language,Handedness,Accuracy,subjExclusion,instrExclusion,accInclusion,Study,Key,FirstOthers
  ) %>% distinct %>% arrange(Subject)

df_others <- df %>% filter(Block == "experiment") %>%
  filter(subjExclusion %>% not) %>%
  select(
    Subject,Gender,otherValence,otherValence2,otherNames,otherRel,otherNum,otherDir,
    valDir,SRIValence,otherSRI,valSRI,subjExclusion,Study,Key,FirstOthers,catGriff,catGriff_ext,catSRI,catSRI_ext
  ) %>% distinct %>% arrange(Subject)

df_val <- df_others %>% filter(subjExclusion %>% not) %>%
  distinct(Subject,otherValence,otherValence2,otherDir,valDir,
           SRIValence,otherSRI,valSRI,catGriff,catGriff_ext,catSRI,catSRI_ext)

df_dir <- df_val %>% distinct(Subject,otherValence,otherValence2,otherDir,valDir)

df_trials <- df %>% filter(Block == "experiment") %>%
  select(
    Subject,Trial,RT,logRT,Prime,primeType,primeSource,primeValence,Target,targetType,
    Condition,Answer,Correct,speedInclusion,accInclusion,subjExclusion,
    nameExclusion,trialInclusion,Inclusion,Accuracy,Gender,Key,FirstOthers,Handedness
  ) %>% distinct %>% arrange(Subject,Trial)
# This should have 80*96=7680 observations!

df_RTDM <- df_others %>%
  distinct(Subject,otherNames,catGriff,otherDir,valDir) %>%
  spread(otherDir,valDir)  %>%
  right_join(
    df_trials,
    by = c("otherNames" = "Prime","Subject")
  ) %>%
  mutate(
    primeDirect = case_when( 
      catGriff == "Ambivalent" ~ "otherAmb",
      Pos > Neg ~ "otherPos",
      Neg > Pos ~ "otherNeg",
      TRUE ~ primeType %>% as.character
      # The most unclear thing here, is what we do with 'indifferent' participants
      # Currently, they get categorised as "univalent": otherPos or otherNeg, depending on the difference between the two direct measures Neg and Pos
      # In the case that these are equal, they get categorised as what they used to be before.
    ) %>% factor(levels = c("letterStr","otherAmb","otherPos","otherNeg","nounPos","nounNeg")),
    targetType = recode(targetType,"adjNeg" = "Neg", "adjPos" = "Pos") %>% factor(levels = c("Pos","Neg")),
    Subject = Subject %>% as.factor,
    Target = Target %>% as.factor,
    logRT = logRT %>% as.numeric()
  )

df_time <- df %>% filter(Block == "experiment") %>%
  select(
    Subject,Gender,subjExclusion,accInclusion,Accuracy
  ) %>% distinct %>% arrange(Subject) %>%
  full_join(df_rawTime,by="Subject")

df_base <- df_raw %>% select(practicePrimes,experimentPrimes,practiceTrials,experimentTrials)

```

#######################
# Demographics & More #
#######################

```{r Inclusions, options}

df_trials %>% group_by(Subject) %>% summarize(
  "excl" = Correct %>% not %>% mean(na.rm=T)
) %$% mean(excl) %>% multiply_by(100) %>% signif(5) %>%
  paste0(.,"% of trials were excluded because they were incorrectly categorized.")

df_trials %>% group_by(Subject) %>% summarize(
  "excl" = speedInclusion %>% not %>% mean(na.rm=T)
) %$% mean(excl) %>% multiply_by(100) %>% signif(5) %>%
  paste0(.,"% of trials were excluded because the response latencies were either too short (<300ms), or too long (>3000ms)") %>%
  cat

df_subj %$% sum(accInclusion %>% not) %>%
  paste("A total of",.,"participants were fully excluded due to extremes in accuracy and/or latency.") %>%
  cat

df_subj %$% sum(subjExclusion) %>%
  paste("A total of",.,"participants were fully excluded due to not following instructions.") %>%
  cat

df_trials %>% filter(!subjExclusion) %>% group_by(Subject) %>% summarize("trialInclusion" = Inclusion %>% mean) %>%
  summarize(trialInclusion %>% mean) %>% as.numeric %>% multiply_by(100) %>% signif(5) %>%
  paste0("In total, ",.,"% of all trials from included participants were included.") %>%
  cat

```

```{r Gender; Language; & Handedness, options}

df_subj %>% filter(accInclusion & !subjExclusion) %>% {
  bind_rows(
    count(., "Var" = "Total"),
    count(., "Var" = Gender),
    count(., "Var" = Language),
    count(., "Var" = Handedness)
  )
} %>% mutate(
  "%" = extract2(.,1,"n") %>%
    divide_by(n,.) %>%
    multiply_by(100) %>%
    signif(4)
)

```

```{r Age & Accuracy, options}

options(pillar.sigfig = 6)
df_subj %>% filter(accInclusion & !subjExclusion) %>% 
  summarize_at(
    vars(Age,Accuracy),
    funs(mean,sd,min,max,median,.args = list(na.rm=T))
  ) %>% gather("Var","Value") %>%
  separate(Var,c("Var","Func"),sep="_") %>%
  spread(Func,Value) %>% select(Var,mean,sd,min,max,median)

```

```{r Control Variables, options}

df_subj %>% filter(accInclusion & !subjExclusion) %>% count(Key,FirstOthers) %>%
  mutate("%" = n %>% divide_by(sum(.)) %>% multiply_by(100))

```

Note, durations are in minutes

```{r Duration of Experiments, options}

df_time %>% filter(accInclusion & !subjExclusion) %>%
  summarize_at(
    vars(starts_with("time")),
    funs(mean,sd,min,max,.args=list(na.rm=T))
  ) %>% gather("Var","Value") %>%
  separate(Var,c("Var","Func"),sep="_") %>%
  spread(Func,Value) %>% select(Var,mean,sd,min,max) %>%
  slice(c(4,5,2,3,1,6))

```

```{r legacy code, eval=FALSE, include=FALSE}

# This code is only here because I am really proud of it, at least the sapply within select.
# It is utterly outdated.

# df %>% mutate(pointTime = gsub("^(.*)$","time\\1",pointTime)) %>%
#   distinct(Subject,pointTime,valTime,subjInclusion) %>%
#   spread(pointTime,valTime) %>%
#   filter(Subject %>% duplicated %>% not & subjInclusion) %>%
#   summarize_at(
#     vars(matches("^time")),
#     funs(mean,sd,min,max,.args=list(na.rm=T))
#   ) %>% select(
#     sapply(
#       c("Other","Practice","Experiment","Explicit","Demographics","Total"),
#       matches
#     ) # I am actually suprised that this works...
#   ) %>% gather("Var","Value") %>% separate(Var,c("Var","Func"),sep="_") %>%
#   spread(Func,Value) %>% select(Var,mean,sd,min,max)

```


######################
# Significant Others #
######################


```{r Names, options}

df_others %>% group_by(otherNames,Subject) %>%
  summarize("otherNum" = otherNum %>% mean(na.rm=T)) %>%
  summarize("n" = n(),"meanOther" = otherNum %>% mean(na.rm=T)) %>%
  arrange(n %>% desc)

df_others %>% group_by(otherNames,Subject) %>%
  summarize("otherNum" = otherNum %>% mean(na.rm=T)) %>%
  summarize("n" = n(),"meanOther" = otherNum %>% mean(na.rm=T),"maxOther"=otherNum %>% max(na.rm=T)) %>%
  group_by(n) %>%
  summarize("nn" = n(),"meanOther" = mean(meanOther,na.rm=T),"maxOther"=maxOther %>% max(na.rm=T))

```

There were 27 included participants who provided 2 or more significant others with the same starting letter.
None of these look like variations of the same name.

```{r names with same starting letter within participants, options}

df_others %>% distinct(otherNames,Subject) %>%
  group_by(Subject) %>%
  filter(otherNames %>% substr(1,1) %>% {or(duplicated(.),duplicated(.,fromLast=T))}) %>%
  arrange(otherNames) %>%
  mutate(id = n() %>% seq_len) %>%
  spread(id,otherNames) # %T>% utils::View(.)

```

By checking all the names, there are a few issues:

Clearly not names:
Derkleine, Derwächter, Niemanden

Probably family names, instead of first names:
Schindler, Stepputtis, Waltraut, Kopp

```{r label, options}

df %>%
  filter(otherNames %in% c("Derkleine","Derwächter","Niemanden","Schindler","Stepputtis","Waltraut","Kopp")) %>%
  distinct(Subject,otherNames,otherRel)

```

The participants who provided the three items that were clearly non-names were excluded.


This shows the answers given in response to the question "What is your relationship with this person?".
Note however that this is not corrected for possible differentations in spelling

```{r Relations, options}

df_others %>% distinct(Subject,otherValence,otherRel) %>%
  count(otherRel) %>% arrange(n%>%desc) # %T>% utils::View(.)

```


```{r Relations NA, options}

df_others %>% distinct(Subject,otherValence,otherRel) %>% arrange(otherRel) %T>% utils::View(.)

df_others %>% filter(Subject == 57) %>% distinct(otherValence,otherNames,otherRel)

df_others %>% filter(otherRel %>% is.na) %>% distinct(Subject,otherValence,otherNames,otherRel)

```

One participant did not supply us with the relation towards their negative significant other.
As this is not the information we need for our primary analyses, and otherwise, this participant will be included in our main analyses.


Note that for 64 participants, the amount of other people with the same first name was not recorded for 1 random significant other.
This was due to a coding mistake in the software, and not because of these participants.

```{r Number of Others with Same Name, options}

df_others %>% distinct(Subject,otherValence,otherNum) %>% count(otherNum)

```


#################################
## Direct Measures Ambivalence ##
#################################

#####################
## Felt & Potential
#####################

```{r Direct Measures of Ambivalence, options}

df_val %>% group_by(otherValence2,otherDir) %>%
  summarize(avgDirect = valDir %>% mean) %>%
  spread(otherDir,avgDirect)

```

```{r mixed model, options}

afex::set_effects_contrasts()
fitDirect <- df_val %>% filter(otherDir != "Griff") %>%
  mixed(
    valDir ~ otherDir * otherValence2 + (1|Subject),
    data=., method = "KR"
  )

fitDirect

summary(fitDirect) %$% coefficients %>% zapsmall #Neat function that puts very small numbers to 0

emmeans(fitDirect,"otherDir")
emmeans(fitDirect,"otherValence2")
emmeans(fitDirect,~otherDir*otherValence2)

fullDirect <- emmeans(fitDirect,~otherDir*otherValence2)

fullDirect %>% contrast(method="revpairwise")

```

```{r mixed model 2, options}

afex::set_effects_contrasts()
fitGriff <- df_val %>% filter(otherDir %in% c("Felt","Griff")) %>%
  mixed(
    valDir ~ otherDir * otherValence2 + (1|Subject),
    data=., method="KR"
  )

fitGriff %>% summary %$% coefficients %>% zapsmall

emmeans(fitGriff,"otherDir")
emmeans(fitGriff,"otherValence2")
emmeans(fitGriff,~otherDir*otherValence2)

fullGriff <- emmeans(fitGriff,~otherDir*otherValence2)

fullGriff %>% contrast(method="revpairwise")

```

```{r graphics, options}

fullDirect %>% as_tibble %>% 
  ggplot(aes(x=otherDir,y=emmean,fill = otherValence2)) +
  geom_col(position=position_dodge2(reverse=TRUE)) +
  guides(fill=guide_legend(reverse=TRUE)) +
  labs(x="Direct Measure",y="Avg Rating",fill="Valence") +
  scale_y_continuous(limits = c(0,100)) +
  scale_x_discrete(limits = c("Pos","Neg","Felt"))

fullGriff %>% as_tibble %>%
  ggplot(aes(x=otherDir,y=emmean,fill=otherValence2)) +
  geom_col(position = position_dodge2(reverse=TRUE)) +
  guides(fill=guide_legend(reverse = TRUE)) +
  labs(x="Direct Measure",y="Avg Rating",fill="Valence") +
  scale_y_continuous(limits = c(-50,100))

```





########
## SRI
########

```{r SRI, options}

df_val %>% group_by(otherValence2,SRIValence) %>%
  summarize(avgSRI=mean(valSRI))

```

```{r mixed models, options}

afex::set_effects_contrasts()
fitSRI <- df_val %>%
  mixed(
    valSRI ~ SRIValence * otherValence2 + (1|otherSRI) + (1|Subject) + (1|otherValence),
    data=., method = "KR",
    check_contrasts = TRUE,
    expand_re=FALSE
  )

fitSRI

summary(fitSRI) %$% coefficients %>% zapsmall

# emmeans(fitSRI,"SRIValence") %>% contrast(method="revpairwise")
# emmeans(fitSRI,"otherValence2") %>% contrast(method="revpairwise")
emmeans(fitSRI, ~SRIValence * otherValence2) %>% contrast(method="revpairwise")

```

```{r graphics, options}
emmeans(fitSRI, ~SRIValence * otherValence2) %>% as_tibble %>% 
  ggplot(aes(x=SRIValence,y=emmean,fill = otherValence2)) +
  geom_col(position=position_dodge2(reverse=TRUE)) +
  guides(fill=guide_legend(reverse=TRUE)) +
  labs(x="SRI Valence",y="Avg SRI",fill="SO Valence") +
  coord_cartesian(ylim=c(1,6)) +
  scale_y_continuous(breaks=seq(1,6,1))

```


############
## Further
############


```{r catSRI, options}

df_val %>% distinct(Subject,otherValence,.keep_all=TRUE) %>% 
  group_by(otherValence2,catSRI) %>% tally %>% mutate(Perc = 100*n/sum(n))

df_val %>% distinct(Subject,otherValence,.keep_all=TRUE) %>% 
  group_by(otherValence2,catSRI_ext) %>% tally %>% mutate(Perc = 100*n/sum(n))

```

Interestingly, our negative others are not strictly aversive, and our positive others are not strictly supportive.
More concerning? though, is that 5 negative others are rated supportive, indicating a minimum of 1 for upsetting.

This might be an artefact of the SRI, which questions specifically helpfulness and upsettingness, and not other constructs of the social relation or positivity and negativity.

```{r catGriff, options}

df_val %>% distinct(Subject,otherValence,.keep_all=TRUE) %>%
  group_by(otherValence2,catGriff) %>% tally %>% mutate(Perc = 100*n/sum(n))

df_val %>% distinct(Subject,otherValence,.keep_all=TRUE) %>%
  group_by(otherValence2,catGriff_ext) %>% tally %>% mutate(Perc = 100*n/sum(n))

```

The interesting thing here is that our negative significant others seem to be more 


```{r cats, options}

df_val %>% distinct(Subject,otherValence,.keep_all=TRUE) %>%
  group_by(otherValence2,catGriff,catSRI) %>% tally %>% mutate(Perc = 100*n/sum(n))

df_val %>% distinct(Subject,otherValence,.keep_all=TRUE) %>%
    mutate(otherValence2 = otherValence2 %>%
           recode(Pos = "Positive", Neg = "Negative")) %>%
  group_by(otherValence2,catGriff,catSRI) %>% tally %>% mutate(Perc = 100*n/sum(n)) %>%
  group_by(otherValence2) %$%
  do(.,
     plots = ggplot(data=.,aes(x=catGriff,y=Perc,fill=catSRI)) +
       geom_col() +
       labs(x = .$otherValence2,y="Percentage") +
       scale_fill_manual(
         values = c(
         ambivalent = hcl(h = 15,l=65,c=100),
         aversive = hcl(h = 105,l=65,c=100),
         indifferent = hcl(h = 195,l=65,c=100),
         supportive = hcl(h = 285,l=65,c=100)
         )
       )
  ) %$%
  plot_grid(
    plots[[1]] +
      theme(legend.position = "none"),
    NULL,
    plots[[2]] +
      theme(
        legend.position = "none",
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank()
      ),
    get_legend(plots[[1]]),
    nrow=1,
    rel_widths = c(1,-.1,1,.3)
  )

# gather(catGriff,catGriff_ext,catSRI,catSRI_ext), then group_by(newvariable), then do(), then plot_grid(nrow=2,ncol=2); only 1 legend though

```





```{r special cats, options}

df_others %>%
  filter(
    (otherValence2 == "Neg" & (catSRI == "supportive" | catSRI_ext == "supportive")) |
      (otherValence2 == "Pos" & (catSRI == "aversive" | catSRI_ext == "aversive"))
  ) %>%
  distinct(
    Subject,otherValence,otherValence2,otherNames,otherRel,otherDir,valDir,catSRI,catSRI_ext
  ) %>%
  arrange(catSRI,otherValence,Subject,otherDir) #%T>% utilss::View(.)

```

The truly problematic cases are:
Subj 34 -> provided for both otherNeg clearly Pos others [could be an error with encoding]
Subj 58 -> provided for both otherNeg clearly Pos others

```{r label, options}

df_others %>% filter(Subject == 34 | Subject == 58) %>% 
  distinct(Subject,otherValence2,otherNames,otherRel,otherDir,valDir,catSRI,catSRI_ext,FirstOthers) %>%
  arrange(Subject,otherValence2,otherNames,otherDir) #%>% View

```

These subjects provided only overwhelmingly positive participants.


```{r Graph, options}

df_dir %>%
  spread(otherDir,valDir) %>%
  mutate(
    otherValence2 = otherValence2 %>%
      recode_factor(
        Pos = "Positive",
        Neg = "Negative"
      )
  ) %>%
  {
    ggplot(data=.,aes(x=Pos,y=Neg,shape=otherValence2,colour=Felt)) +
      geom_point(alpha=.6,size=3) +
      labs(x="Positivity",y="Negativity") +
      guides(
        shape = guide_legend(title="Acquaintance\nValence",override.aes = list(alpha=1,size=5)),
        colour = guide_legend(title="Felt\nAmbivalence",override.aes = list(size=5))
      ) +
      scale_colour_gradient2(low = "black",mid = "orange",high="red",midpoint = 50) +
      scale_shape_manual(values=c(1,4)) +
      theme(plot.margin=margin(1.5,0.5,0.5,0.5,"cm"))
  } %>%
  ggdraw() +
  draw_text("Reported Direct Measures of Acquaintances",x=.45,y=.95)


df_dir %>% filter(otherDir != "Griff") %>%
  ggplot(aes(x=otherDir,y=valDir,colour=otherValence2)) +
  geom_point(alpha=.4,position=position_dodge2(width = .75,reverse=TRUE)) +
  labs(x = "Direct Measures", y = "Ratings", title="Direct Measures of SOs") +
  guides(colour = guide_legend(title="Valence" ,override.aes = list(alpha=1,size=5),reverse=TRUE))

df_dir %>% filter(otherDir %in% c("Griff","Felt")) %>%
  spread(otherDir,valDir) %>%
  ggplot(aes(x=Griff,y=Felt,colour=otherValence2)) +
  geom_point(alpha=.4,position=position_dodge2(width=0,reverse=TRUE)) +
  labs(x="Griffin Index", y = "Felt Ambivalence", title="Comparison Potential and Felt Ambivalence") +
  guides(colour = guide_legend(title="Valence",override.aes=list(alpha=1,size=5),reverse=TRUE))

df_val %>% group_by(SRIValence,Subject,otherValence,otherValence2) %>%
  summarize(valSRI = mean(valSRI)) %>%
  spread(SRIValence,valSRI) %>%
  ggplot(aes(x=Helpful,y=Upsetting,colour=otherValence2)) +
  geom_jitter(alpha=.3,size=3) +
  labs(title="Social Relationship Index (SRI) Scores", x="Helpfulness",y="Upsettingness") +
  scale_x_continuous(breaks=seq(1,6)) +
  scale_y_continuous(breaks=seq(1,6)) +
  guides(colour = guide_legend(title = "Valence", override.aes=list(alpha=1,size=5), reverse=TRUE))
  
df_val %>%
  distinct(Subject,otherValence,otherValence2,otherDir,valDir,catSRI,catSRI_ext) %>%
  spread(otherDir,valDir) %>%
  ggplot(aes(x=Pos,y=Neg,colour=otherValence2,size=Felt,shape=catSRI_ext)) +
  geom_point(alpha=.4,position=position_dodge2(width=0,reverse=TRUE),stroke=1.5) +
  labs(title="Grid of Direct Measures",x="Positivity",y="Negativity") +
  scale_shape_manual(values=c(1,0,5,2)) +
  guides(
    colour = guide_legend(title="Valence",override.aes = list(alpha=1,size=3),reverse=TRUE),
    shape = guide_legend(
      title="SRI category",
      override.aes = list(alpha=1,size=3,stroke=1,fill="black")),
    size = guide_legend(title="Felt\nAmbivalence")
  )

```


```{r t.tests & levene's, options}

# First centering separate for Pos and Neg Valence
# Resulting homogeinity test is only significant for Felt Ambivalence ("Amb")
df_val %>%
  distinct(Subject,otherValence,otherValence2,otherDir,valDir) %>%
  spread(otherDir,valDir) %>%
  group_by(otherValence2) %$% {
    car::leveneTest(Felt ~ otherValence2) %>% print
    car::leveneTest(Pos ~ otherValence2) %>% print
    car::leveneTest(Neg ~ otherValence2) %>% print
    car::leveneTest(zGriff ~ otherValence2) %>% print
  }

df_val %>%
  distinct(Subject,otherValence,otherValence2,otherDir,valDir) %>%
  spread(otherDir,valDir) %>%
  mutate(Griff = griffinFormula(Pos,Neg)) %$% {
    t.test(Amb ~ otherValence2) %>% print
    t.test(Pos ~ otherValence2) %>% print
    t.test(Neg ~ otherValence2) %>% print
    t.test(Griff ~ otherValence2) %>% print
  }

test <- df_val %>%
  distinct(Subject,otherValence,otherValence2,otherDir,valDir) %>%
  spread(otherDir,valDir) %>%
  mutate(Griff = griffinFormula(Pos,Neg)) %>%
  group_by(otherValence) %>%
  summarize(mean(Griff))

```




###########
# Stimuli 
###########

The positive adjective targets were:
BELIEBT GENIAL GESUND LEBENDIG OPTIMAL PERFEKT SONNIG SUPER

The negative adjective targets were:
BRUTAL EINSAM ELEND GRAUSAM ILLEGAL KRANK TRAGISCH TRAURIG

```{r Targets, options}

# bawlTargets <- bawl %>% 
#   filter(
#     WORD %in% c("BELIEBT","GENIAL","GESUND","LEBENDIG","OPTIMAL","PERFEKT","SONNIG","SUPER") |
#       WORD %in% c("BRUTAL","EINSAM","ELEND","GRAUSAM","ILLEGAL","KRANK","TRAGISCH","TRAURIG")
#   ) %>% mutate(POSITIVE = EMO_MEAN > 0) %>%
#   select(WORD,POSITIVE,EMO_MEAN,EMO_STD,AROUSAL_MEAN,AROUSAL_STD,IMAGE_MEAN,IMAGE_STD,LETTERS,`Ftot/1MIL`) %>%
#   arrange(POSITIVE,WORD)

```

The positive noun primes were:
Mut Lust Glück Freude Frieden Hoffnung Vertrauen Wochenende

The negative noun primes were:
Not Leid Feind Streit Drohung Abschied Gefängnis Verbrechen

```{r Primes, options}

# bawlPrimes <- bawl %>% 
#   filter(
#     WORD_LOWER %in% c("mut","lust","glück","freude","frieden","hoffnung","vertrauen","wochenende") |
#       WORD_LOWER %in% c("not","leid","feind","streit","drohung","abschied","gefängnis","verbrechen")
#   ) %>% mutate(POSITIVE = EMO_MEAN > 0) %>%
#   select(WORD,POSITIVE,EMO_MEAN,EMO_STD,AROUSAL_MEAN,AROUSAL_STD,IMAGE_MEAN,IMAGE_STD,LETTERS,`Ftot/1MIL`) %>%
#   arrange(POSITIVE,WORD)

```

#################
# Main Analyses 
#################

```{r Control, options}

df_trials %>% count(Subject) %$% unique(n) %>%
  paste("Each subject viewed a total of",.,"trials.")

df_trials %>% filter(Subject == 1) %>% count(primeType)

df_trials %>% filter(Subject == 1) %>% count(targetType)

df_trials %>% filter(Subject == 1) %>% count(primeType,targetType)

```

```{r model with random intercepts for subject and target, cache=TRUE}
# emmeans::emm_options(pbkrtest.limit=8000,lmerTest.limit=8000) # This allows for df estimates, but makes it run way slower.
afex::set_effects_contrasts()
fitAfex <- df_trials %>% filter(Inclusion) %>% {
  mixed(
    logRT ~ primeType * targetType + (1|Target) + (1|Subject),
    data=., method = "KR",
    check_contrasts = TRUE,
    expand_re=FALSE
  )
}

fitAfex

summary(fitAfex) %$% coefficients %>% zapsmall #Neat function that puts very small numbers to 0

# emm_options(pbkrtest.limit = 7000) # This allows for df estimates, but makes it run way slower.

targetMeans <- emmeans(fitAfex,"targetType")
primeMeans <- emmeans(fitAfex,"primeType")
fullMeans <- emmeans(fitAfex,~primeType*targetType)

fullContr <- fullMeans %>%
  contrast(method="revpairwise") %>% as_tibble %>%
  separate(contrast,c("contrastA","contrastB"),sep=" - ") %>%
  separate(contrastA,c("cPrimeA","cTargetA"),sep=",") %>%
  separate(contrastB,c("cPrimeB","cTargetB"),sep=",") %>%
  arrange(cPrimeB,cPrimeA,cTargetA)

specificContr <- fullContr %>%
  filter(
    (cPrimeA == "otherNeg" | cPrimeA == "otherPos") & cTargetA == cTargetB
  ) %>% arrange(cPrimeB,cPrimeA,cTargetA)

primeContr <- primeMeans %>%
  contrast(method="revpairwise") %>% as_tibble %>%
  separate(contrast,c("contrastA","contrastB"),sep=" - ") %>%
  arrange(contrastA,contrastB)


```

```{r label, options}

specificContr

fullContr %>%
  filter(cPrimeA==cPrimeB)

fullContr %>%
  filter((cPrimeA == "otherPos" & cPrimeB == "nounNeg" & cTargetA == "adjNeg" & cTargetB == "adjNeg") | (
    cPrimeA == "otherNeg" & cPrimeB == "nounPos" & cTargetA == "adjPos" & cTargetB == "adjPos"))

fullContr %>%
  filter(cTargetA == cTargetB) %>%
  filter(
    (cPrimeA == "otherNeg" & cPrimeB == "letterStr" & cTargetA == "adjPos") |
      (cPrimeA == "otherNeg" & cPrimeB == "nounPos" & cTargetA == "adjPos") |
      (cPrimeA == "otherPos" & cPrimeB == "letterStr" & cTargetA == "adjNeg") |
      (cPrimeA == "otherPos" & cPrimeB == "nounNeg" & cTargetA == "adjNeg")
  )

```

############
## Graphs 
############

This needs a y-axis denominator (delta(log(RT)))

```{r contrast comparisons, options}

specificContr %>% filter(not(cPrimeA == "otherPos" & cPrimeB == "otherNeg")) %>%
  group_by(cPrimeA,cPrimeB) %>%
  do(
    plots = ggplot(.,aes(x=cPrimeA,y=estimate,fill=cTargetA)) +
      geom_col(position=position_dodge2(reverse=TRUE)) +
      ggtitle(paste(.$cPrimeA,"-",.$cPrimeB)) +
      labs(x="",y="") +
      scale_x_discrete(labels=NULL,breaks=NULL) +
      scale_y_continuous(limits=c(-0.15,.15)) +
      geom_label(
        aes(
          label=case_when(
            p.value < .001 ~ '***',
            p.value < .01 ~ '**',
            p.value < .05 ~ '*',
            TRUE ~ NA_character_
          )
        ),position = position_dodge2(width=.9,reverse=TRUE))+
      theme(legend.position="none")
  ) %$% 
  list(
    plot_grid(
      plotlist=plots,align="hv",nrow=2),
    get_legend(
      ggplot(specificContr,aes(x=cPrimeA,y=estimate,fill=cTargetA)) +
        geom_col() +
        guides(fill=guide_legend(title="Target",reverse=TRUE))
    )
  ) %>%
  plot_grid(
    plotlist = .,
    rel_widths = c(1,.15),
    scale = c(1,.8)
  ) %>%
  plot_grid(
    ggdraw() + draw_label("Comparisons of Prime Conditions",fontface="bold"),
    .,
    ncol=1, rel_heights = c(0.1,1)
  )

```

```{r label, options}

# fullMeans %>% as_tibble %>%
#   mutate(
#     RT = emmean %>% exp,
#     primeType= primeType %>% factor(levels=levels(.) %>% sort(decreasing=TRUE)),
#     primes = case_when(
#       grepl("(other)",primeType) ~ "Significant\nOthers",
#       grepl("(noun)",primeType) ~ "Univalent\nNouns",
#       grepl("(letter)",primeType) ~ "Letter\nStrings"
#     ),
#     primeValence = case_when(
#       grepl("(Pos)",primeType) ~ "Positive",
#       grepl("(Neg)",primeType) ~ "Negative",
#       grepl("(Str)",primeType) ~ NA_character_
#     ),
#     Targets = targetType %>% factor(levels=levels(.) %>% sort(decreasing=TRUE)) %>%
#       recode_factor(
#         "adjPos" = "Positive",
#         "adjNeg" = "Negative"
#       )
#     ) %>%
#   ggplot(aes(x=primeValence,y=RT,fill=Targets)) +
#   geom_col(position=position_dodge2()) +
#   labs(x="Primes",y="Reaction Time (ms)") +
#   guides(fill=guide_legend(title="Target\nValence")) +
#   geom_label(data = fullContr %>% filter(cPrimeA==cPrimeB),
#              aes(x=cPrimeA,y=1,label=case_when(
#                p.value < .001 ~ '***',
#                p.value < .01 ~ '**',
#                p.value < .05 ~ '*',
#                TRUE ~ p.value %>% signif(3) %>% as.character
#              )),
#              inherit.aes = FALSE) +
#   theme_bw()



fullMeans %>% as_tibble %>%
  mutate(
    RT = emmean %>% exp,
    primeType= primeType %>% factor(levels=levels(.) %>% sort(decreasing=TRUE)),
    primes = case_when(
      grepl("(other)",primeType) ~ "Significant\nOthers",
      grepl("(noun)",primeType) ~ "Univalent\nNouns",
      grepl("(letter)",primeType) ~ "Letter\nStrings"
    ) %>% factor(levels=c("Significant\nOthers","Univalent\nNouns","Letter\nStrings")),
    primeValence = case_when(
      grepl("(Pos)",primeType) ~ "Positive",
      grepl("(Neg)",primeType) ~ "Negative",
      grepl("(Str)",primeType) ~ NA_character_
    ) %>% factor(levels=c("Positive","Negative")),
    Targets = targetType %>% factor(levels=levels(.) %>% sort(decreasing=TRUE)) %>%
      recode_factor(
        "adjPos" = "Positive",
        "adjNeg" = "Negative"
      )
    ) %>%
  filter(primeValence %>% is.na %>% not) %>%
  ggplot(aes(x=primeValence,y=RT,fill=Targets)) +
  geom_col(position=position_dodge2()) +
  labs(x="Primes",y="Reaction Time (ms)") +
  guides(fill=guide_legend(title="Target\nValence")) +
  facet_wrap("primes",strip.position="bottom",scales="free_x") +
  theme(panel.spacing = unit(0,"lines"),
        strip.background = element_blank(),
        strip.placement = "outside")




ggMeans <- fullMeans %>% as_tibble %>%
  mutate(
    RT = emmean %>% exp,
    yminRT = lower.CL %>% exp,
    ymaxRT = upper.CL %>% exp,
    primeType= primeType %>% factor(levels=levels(.) %>% sort(decreasing=TRUE)),
    primes = case_when(
      grepl("(other)",primeType) ~ "Acquaintances",
      grepl("(noun)",primeType) ~ "Univalent Nouns",
      grepl("(letter)",primeType) ~ "Letter Strings"
    ) %>% factor(levels=c("Acquaintances","Univalent Nouns","Letter Strings")),
    primeValence = case_when(
      grepl("(Pos)",primeType) ~ "Positive",
      grepl("(Neg)",primeType) ~ "Negative",
      grepl("(Str)",primeType) ~ NA_character_
    ) %>% factor(levels=c("Positive","Negative")),
    Targets = targetType %>% factor(levels=levels(.) %>% sort(decreasing=TRUE)) %>%
      recode_factor(
        "adjPos" = "Positive",
        "adjNeg" = "Negative"
      )
    ) %>%
  filter(primeValence %>% is.na %>% not)

ggCritContrasts <- specificContr %>%
  filter(cPrimeB != "letterStr" & cPrimeB != "otherNeg") %>%
  filter(not(cPrimeA == "otherNeg" & cTargetA == "adjNeg") & not(cPrimeA == "otherPos" & cTargetA == "adjPos")) %>%
  arrange(cTargetA,cPrimeB) %>%
  mutate(
    p = case_when(
      p.value < .001 ~ '***',
      p.value < .01 ~ '**',
      p.value < .05 ~ '*',
      TRUE ~ p.value %>% signif(3) %>% as.character %>% substr(2,length(.)+1)
    )
  )

acqPosNeg <- .24
acqNegPos <- .33
nounPosPos <- .52
nounPosNeg <- .59
nounNegPos <- .68
nounNegNeg <- .75
adjust <- .0015

{
  ggplot(data=ggMeans,aes(x=primeValence,y=RT,fill=Targets,ymin=yminRT,ymax=ymaxRT)) +
    geom_errorbar(position=position_dodge2(padding=.75),colour="black",size=.5) +
    geom_col(position=position_dodge2()) +
    facet_wrap("primes",strip.position="bottom",scales="free_x") +
    labs(x="Primes",y="Reaction Time (ms)") +
    guides(fill=guide_legend(title="Target\nValence")) +
    scale_y_continuous(breaks = seq(0,800,200)) +
    theme(panel.spacing.x=unit(0,"lines"),
          strip.background = element_blank(),
          strip.placement = "outside",
          strip.text = element_text(margin = margin(0.15,0,0.15,0,unit="cm")),
          plot.margin = margin(1.5,0.5,0.5,0.5,"cm"))
  } %>%
  ggdraw() +  
  geom_segment(aes(x=acqPosNeg,xend=nounNegNeg,y=.55,yend=.55),colour="black",size=2) +
  geom_segment(aes(x=acqPosNeg+adjust,xend=nounNegNeg-adjust,y=.55,yend=.55),colour="red",size=1) +
  geom_tile(aes(x=.46,y=.55,width=.04,height=.025),fill="white",colour="black") +
  draw_label(ggCritContrasts$p[[1]],x=.46,y=.545)+
  geom_segment(aes(x=acqPosNeg,xend=nounPosNeg,y=.35,yend=.35),colour="black",size=2) +
  geom_segment(aes(x=acqPosNeg+adjust,xend=nounPosNeg-adjust,y=.35,yend=.35),colour="green",size=1) +
  geom_tile(aes(x=.46,y=.35,width=.04,height=.025),fill="white",colour="black") +
  draw_label(ggCritContrasts$p[[2]],x=.46,y=.345) +
  geom_segment(aes(x=acqNegPos,xend=nounNegPos,y=.40,yend=.40),colour="black",size=2) +
  geom_segment(aes(x=acqNegPos+adjust,xend=nounNegPos-adjust,y=.40,yend=.40),colour="green",size=1) +
  geom_tile(aes(x=.46,y=.40,width=.04,height=.025),fill="white",colour="black") +
  draw_label(ggCritContrasts$p[[3]],x=.46,y=.402,size=9) +
  geom_segment(aes(x=acqNegPos,xend=nounPosPos,y=.60,yend=.60),colour="black",size=2) +
  geom_segment(aes(x=acqNegPos+adjust,xend=nounPosPos-adjust,y=.60,yend=.60),colour="red",size=1) +
  geom_tile(aes(x=.46,y=.60,width=.04,height=.025),fill="white",colour="black") +
  draw_label(ggCritContrasts$p[[4]],x=.46,y=.595) +
  draw_text("Comparisons of Latency between Acquiantances and Univalent Nouns",x=.45,y=.95)
  


```

```{r label, options}

ggMeansStr <- fullMeans %>% as_tibble %>%
  mutate(
    RT = emmean %>% exp,
    yminRT = lower.CL %>% exp,
    ymaxRT = upper.CL %>% exp,
    primeType= primeType %>% factor(levels=levels(.) %>% sort(decreasing=TRUE)),
    primes = case_when(
      grepl("(other)",primeType) ~ "Acquaintances",
      grepl("(noun)",primeType) ~ "Univalent Nouns",
      grepl("(letter)",primeType) ~ "Letter Strings"
    ) %>% factor(levels=c("Acquaintances","Univalent Nouns","Letter Strings")),
    primeValence = case_when(
      grepl("(Pos)",primeType) ~ "Positive",
      grepl("(Neg)",primeType) ~ "Negative",
      grepl("(Str)",primeType) ~ " "
    ) %>% factor(levels=c("Positive","Negative"," ")),
    Targets = targetType %>% factor(levels=levels(.) %>% sort(decreasing=TRUE)) %>%
      recode_factor(
        "adjPos" = "Positive",
        "adjNeg" = "Negative"
      )
    ) %>%
  filter(primeType %in% c("letterStr","otherPos","otherNeg"))

{
  ggplot(data=ggMeansStr,aes(x=primeValence,y=RT,fill=Targets,ymin=yminRT,ymax=ymaxRT)) +
    geom_errorbar(position=position_dodge2(padding=.75),colour="black",size=.5) +
    geom_col(position=position_dodge2()) +
    facet_wrap("primes",strip.position="bottom",scales="free_x") +
    labs(x="Primes",y="Reaction Time (ms)") +
    guides(fill=guide_legend(title="Target\nValence")) +
    scale_y_continuous(breaks = seq(0,800,200)) +
    theme(panel.spacing.x=unit(0,"lines"),
          strip.background = element_blank(),
          strip.placement = "outside",
          strip.text = element_text(margin = margin(0.15,0,0.15,0,unit="cm")),
          plot.margin = margin(1.5,0.5,0.5,0.5,"cm"))
  } %>%
  ggdraw() +
  draw_text("Comparisons of Latency between Acquiantances and Letter Strings",x=.45,y=.95)







ggStringContrasts <- specificContr %>%
  filter(cPrimeB == "letterStr") %>%
  arrange(cTargetA,cPrimeB) %>%
  mutate(
    p = case_when(
      p.value < .001 ~ '***',
      p.value < .01 ~ '**',
      p.value < .05 ~ '*',
      TRUE ~ p.value %>% signif(3) %>% as.character %>% substr(2,length(.)+1)
    ),
    primes = case_when(
      grepl("(other)",cPrimeA) ~ "Acquaintances"
    ) %>% factor(levels=c("Acquaintances")),
    primeValence = case_when(
      grepl("(Pos)",cPrimeA) ~ "Positive",
      grepl("(Neg)",cPrimeA) ~ "Negative"
    ) %>% factor(levels=c("Positive","Negative")),
    Targets = cTargetA %>%
      recode_factor(
        "adjPos" = "Positive",
        "adjNeg" = "Negative"
      )
  )




ggMeansDelta <- ggMeansStr %>% {
  left_join(
    filter(.,primeType != "letterStr"),
    select(.,primeType,RT,Targets) %>%
      spread(primeType,RT) %>%
      gather(primeType,RT,otherPos,otherNeg) %>%
      mutate(
        deltaRT = subtract(RT,letterStr)
      ) %>%
      select(-RT,-letterStr),
    by=c("primeType","Targets")
  )
} %>%
select(primeType,targetType,RT,deltaRT,everything())



{
  ggplot(data=ggMeansDelta,aes(x=primeValence,y=deltaRT,fill=Targets,ymin=yminRT,ymax=ymaxRT)) +
    geom_col(position=position_dodge2()) +
    facet_wrap("primes",strip.position="bottom",scales="free_x") +
    labs(x=NULL,y=expression(Delta * " Reaction Time (ms)")) +
    guides(fill=guide_legend(title="Target\nValence")) +
    scale_y_continuous(breaks = seq(-20,100,20)) +
    geom_label(
      data = ggStringContrasts,
      aes(x=primeValence,y=0,label=p,group=Targets),
      position=position_dodge2(width=.9),
      inherit.aes = FALSE
    ) +
    theme(panel.spacing.x=unit(0,"lines"),
          strip.background = element_blank(),
          strip.placement = "outside",
          strip.text = element_text(margin = margin(0.15,0,0.15,0,unit="cm")),
          plot.margin = margin(1.5,0.5,0.5,0.5,"cm"))
  } %>%
  ggdraw() +
  draw_text("Difference in Latency between Acquiantances and Letter Strings",x=.45,y=.95)


```


```{r label, options}
  
  ggplot(data=ggMeans,aes(x=primeType,y=RT,fill=Targets,ymin=yminRT,ymax=ymaxRT)) +
  geom_col(position=position_dodge2()) +
  geom_errorbar(position=position_dodge2(padding=.75),colour="black",size=.5)


  geom_segment(aes(x=c(1.25),xend=c(3.25),y=c(850),yend=c(850))) +
  geom_segment(aes(x=c(1.25),xend=c(4.25),y=c(900),yend=c(900))) +
  geom_segment(aes(x=c(1.75),xend=c(3.75),y=c(950),yend=c(950))) +
  geom_segment(aes(x=c(1.75),xend=c(4.75),y=c(1000),yend=c(1000)))
  



```



```{r label, options}

quickplot <- function(data){
  ggplot(data=data,
         aes(x=primeType,y=emmean,fill=targetType,
             ymin=asymp.LCL,ymax=asymp.UCL,
             colour=Condition,size=ifelse(Condition=="Congruent",1,0))
  ) +
    geom_col(position=position_dodge2(reverse=TRUE)) +
    labs(x=NULL,y="Reaction Times (ms)") +
    guides(fill=guide_legend(title="Target\nValence",reverse=TRUE),
           colour=FALSE,size=FALSE) +
    scale_fill_manual(values=c('#00BFC4','#F8766D'),labels=c('Negative','Positive')) +
    theme(plot.margin = unit(c(1.4,0.4,0.4,0.4), "cm")) +
    geom_errorbar(position=position_dodge2(padding=.8,reverse=TRUE),
                  colour="black",size=.5) +
    scale_y_continuous(limits=c(0,820),expand=c(0,0,0.05,0)) +
    scale_colour_manual(values=c("black","white")) +
    scale_size_identity()
}


fullMeans %>% as_tibble %>%
  mutate_at(
    vars(emmean,asymp.LCL,asymp.UCL),
    .funs=exp) %>%
  mutate(
    primeType = 
      primeType %>%
      recode_factor(
        otherPos = "Positive\nSign. Others",
        otherNeg = "Negative\nSign. Others",
        nounPos = "Univalent\nPositive",
        nounNeg = "Univalent\nNegative",
        letterStr = "Neutral\nLetters"
      ),
    Condition = 
      case_when(
        grepl("Neg",primeType) & grepl("Neg",targetType) ~ "Congruent",
        grepl("Pos",primeType) & grepl("Pos",targetType) ~ "Congruent",
        TRUE ~ "Incongruent"
      )
  ) %>% 
  {
    plot_grid(
      plot_grid(
        quickplot(
          filter(.,primeType %in% c("Positive\nSign. Others","Neutral\nLetters"))
        ) + theme(legend.position="none"),
        quickplot(
          filter(.,primeType %in% c("Negative\nSign. Others","Neutral\nLetters"))
        ) + theme(
          legend.position="none",
          axis.line.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.title.y = element_blank(),
          axis.text.y = element_blank()
        ),
        quickplot(
          filter(.,primeType %in% c("Positive\nSign. Others","Univalent\nNegative"))
        ) + theme(legend.position="none"),
        quickplot(
          filter(.,primeType %in% c("Negative\nSign. Others","Univalent\nPositive"))
        ) + theme(
          legend.position="none",
          axis.line.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.title.y = element_blank(),
          axis.text.y = element_blank()
        ),
        rel_widths = c(1,.8),
        rel_heights = c(1,1)
      ),
      get_legend(quickplot(.)),
      rel_widths = c(1,.2)
    )
  }


```


####################################
## Interactions Pos-Neg Separated ##
####################################

```{r label, options}
afex::set_effects_contrasts()
fitIntOther <- df_trials %>%
  filter(Inclusion & c(primeType %in% c('otherPos','otherNeg'))) %>%
  mixed(
    logRT ~ primeType * targetType + (1|Target) + (1|Subject),
    data=., method = "KR",
    check_contrasts = TRUE,
    expand_re=FALSE
  )

afex::set_effects_contrasts()
fitIntNoun <- df_trials %>%
  filter(Inclusion & c(primeType %in% c('nounPos','nounNeg'))) %>%
  mixed(
    logRT ~ primeType * targetType + (1|Target) + (1|Subject),
    data=., method = "KR",
    check_contrasts = TRUE,
    expand_re=FALSE
  )

fitIntOther %>% summary

fitIntNoun %>% summary

```

```{r graphs, options}

graphIntOthers <- fitIntOther %>% emmeans(~primeType:targetType) %>% as_tibble %>%
  mutate_at(
    .vars = vars(emmean,asymp.LCL,asymp.UCL),
    .funs = exp
  ) %>%
  select(-c(SE,df)) %>%
  mutate(
    targetType = recode_factor(
      targetType,
      "adjPos" = "Positive",
      "adjNeg" = "Negative"
    ),
    primeType = recode_factor(
      primeType,
      "otherPos" = "Positive",
      "otherNeg" = "Negative"
    ),
    Condition = if_else(
      primeType == targetType,
      "Congruent",
      "Incongruent"
    )
  ) %>%
  ggplot(aes(x=primeType,y=emmean,fill=targetType,
             colour=Condition,ymin=asymp.LCL,ymax=asymp.UCL,
             size=ifelse(Condition=="Congruent",1,0))) +
  geom_col(position=position_dodge2()) +
  geom_errorbar(position=position_dodge2(padding=.8),
                colour="black",size=.5) +
  scale_colour_manual(values=c("black","white"),aesthetics = c("colour")) +
  scale_y_continuous(limits=c(0,820),expand=c(0,0,0.05,0)) +
  scale_size_identity() +
  guides(fill=guide_legend(title="Target\nValence"),
         colour=FALSE,size=FALSE) +
  labs(x="Prime Valence",y="Reaction Time (ms)",title="Significant Other Primes")

graphIntNoun <- fitIntNoun %>% emmeans(~primeType:targetType) %>% as_tibble %>%
  mutate_at(
    .vars = vars(emmean,asymp.LCL,asymp.UCL),
    .funs = exp
  ) %>%
  select(-c(SE,df)) %>%
  mutate(
    targetType = recode_factor(
      targetType,
      "adjPos" = "Positive",
      "adjNeg" = "Negative"
    ),
    primeType = recode_factor(
      primeType,
      "nounPos" = "Positive",
      "nounNeg" = "Negative"
    ),
    Condition = if_else(
      primeType == targetType,
      "Congruent",
      "Incongruent"
    )
  ) %>%
  ggplot(aes(x=primeType,y=emmean,fill=targetType,colour=Condition,
             ymin=asymp.LCL,ymax=asymp.UCL,
             size=ifelse(Condition=="Congruent",1,0))) +
  geom_col(position=position_dodge2()) +
  geom_errorbar(position=position_dodge2(padding=.8),
                colour="black",size=.5) +
  scale_colour_manual(values=c("black","white"),aesthetics = c("colour")) +
  scale_y_continuous(limits=c(0,820),expand=c(0,0,0.05,0)) +
  scale_size_identity() +
  guides(fill=guide_legend(title="Target\nValence"),
         colour=FALSE,size=FALSE) +
  labs(x="Prime Valence",y="Reaction Time (ms)",title="Univalent Noun Primes")

plot_grid(
  graphIntOthers +
    guides(fill=FALSE) +
    labs(title="",x="Significant Other Primes"),
  NULL,
  graphIntNoun +
    guides(fill=FALSE) +
    labs(title="",x="Univalent Noun Primes") +
    theme(
      axis.line.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.title.y = element_blank(),
      axis.text.y = element_blank()
    ),
  NULL,
  get_legend(graphIntOthers),
  nrow = 1,
  rel_widths = c(1,-.1,.85,-.075,.25),
  rel_heights = c(1,.2)
  ) +
  draw_label("Interaction Comparison",x=.5,y=.95,size=18)

```

#######################
# Additional Analyses 
#######################

############
## RT & DM
############


```{r explore, options}

df_RTDM %>%
  count(primeDirect)

```


```{r mixed model, options}

# Kathi:
# correlationPB <- mixed(log ~ zgriffin * zfelt + (1|vpnr) + (1|prime) + (1|target), data = test2,
#                        type = 2, method = 'PB', cl = MyCluster, args_test = list(nsim = 1000, cl = MyCluster))
# with zgriffin <- round(scale(griffin, center = TRUE, scale = TRUE), 2) and zfelt similarly

myCluster <- makeCluster(rep("localhost",detectCores()-1))
afex::set_effects_contrasts()
fitRTGriff <- df_RTDM %>% filter(Inclusion & primeSource == "other") %>%
  mixed(
    logRT ~ zGriff * zFelt + (1|Subject) + (1|Target) + (1|primeValence),
    data = .,
    method = "PB",
    type = 2,
    cl = myCluster,
    args_test = list(nsim = 1000, cl = myCluster)
  )
stopCluster(myCluster)

afex::set_effects_contrasts()
fitRTDM <- df_RTDM %>% filter(Inclusion) %>%
  mixed(
    logRT ~ primeDirect * targetType + (1|Subject) + (1|Target),
    data=.,
    method="KR"
  )

fitRTGriff %>% summary %>% coefficients %>% zapsmall

fitRTDM %>% summary %>% coefficients %>% zapsmall

emm_options(lmerTest.limit=7000)
fullRTDM <- fitRTDM %>% emmeans(~ primeDirect * targetType)

contrRTDM <- fullRTDM %>% contrast(method="pairwise") %>% as_tibble %>%
  separate(contrast,c("primeA","targetA","primeB","targetB"),sep="(,)|( - )")

```

This should still receive a title

```{r ambivalent comparison, options}

contrRTDM %>%
  mutate(
    targetA = targetA %>% factor(levels = c("Pos","Neg")),
    targetB = targetB %>% factor(levels=c("Pos","Neg"))
  ) %>%
  filter(primeA == "otherAmb" | primeB == "otherAmb") %>%
  filter(targetA == targetB) %>% 
  group_by(primeA,primeB) %>%
  do(
    plots = ggplot(.,aes(x=primeA,y=estimate,fill=targetA)) +
      geom_col(position = position_dodge2()) +
      labs(x=NULL,y=expression(Delta),title=paste(.$primeA,"-",.$primeB))  +
      scale_y_continuous(limits = c(-0.1,0.1)) +
      scale_fill_discrete(labels = c("Positive","Negative")) +
      geom_label(
        aes(
          label = case_when(
            p.value < .001 ~ '***',
            p.value < .01 ~ '**',
            p.value < .05 ~ '*',
            TRUE ~ NA_character_
          ),
          y = 0
        ),
        position = position_dodge2(width = .9),
        show.legend = FALSE
      ) +
      guides(fill=guide_legend(title="Target\nValence")) +
      theme(
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),
        panel.spacing = margin(.5,1.5,.5,0,unit="cm"),
        plot.margin = margin(.75,0,.75,0,unit="cm"),
        axis.title.y = element_text(vjust = 1,angle=0),
        title = element_text(hjust=.8)
      )
  ) %$%
  plot_grid(
    plots[[1]] + theme(legend.position="none",aspect.ratio = 1,panel.spacing = margin(0,0,0,0,unit="cm"),plot.margin=margin(0,.5,0,0,unit="cm")),
    plot_grid(
      plots[[2]] +
        theme(legend.position="none"),
      plots[[3]] +
        theme(legend.position="none"),
      plots[[4]] +
        theme(legend.position="none"),
      plots[[5]] +
        theme(legend.position="none"),
      nrow=2,
      rel_widths = c(1,1,1,1)
    ),
    get_legend(plots[[1]] + theme(legend.margin=margin(0,0,1.5,.5,unit="cm"))),
    nrow=1,
    rel_widths = c(.5,1,.25)
  )

```


```{r RT by Primes, options}

fullRTDM %>%
  as_tibble %>%
  mutate(
    rt = emmean %>% exp,
    targetType = targetType %>% factor(levels = c("Pos","Neg"))
         ) %>%
  ggplot(aes(x=primeDirect,y=rt,fill=targetType)) +
  geom_col(position=position_dodge2()) +
  labs(x="Primes",y="Reaction Times (ms)") +
  guides(fill=guide_legend(title="Target\nValence")) +
  scale_fill_discrete(labels=c('Positive','Negative')) +
  geom_label(data = contrRTDM %>% filter(primeA==primeB),
             aes(x=primeA,y=1,label=case_when(
               p.value < .001 ~ '***',
               p.value < .01 ~ '**',
               p.value < .05 ~ '*',
               TRUE ~ NA_character_
             )),
             inherit.aes = FALSE)

```

```{r Unival Comp, options}

contrRTDM %>%
  mutate(
    targetA = targetA %>% factor(levels = c("Pos","Neg")),
    targetB = targetB %>% factor(levels=c("Pos","Neg"))
  ) %>%
  filter(primeA != "otherAmb" & primeB != "otherAmb") %>%
  filter(targetA == targetB) %>%
  filter(xor(grepl("other",primeA),grepl("other",primeB))) %>%
  group_by(primeA,primeB) %>%
  do(
    plots = ggplot(.,aes(x=primeA,y=estimate,fill=targetA)) +
      geom_col(position = position_dodge2()) +
      labs(x=NULL,y=expression(Delta),title=paste(.$primeA,"-",.$primeB))  +
      scale_y_continuous(limits = c(-0.16,0.16)) +
      scale_fill_discrete(labels = c("Positive","Negative")) +
      geom_label(
        aes(
          label = case_when(
            p.value < .001 ~ '***',
            p.value < .01 ~ '**',
            p.value < .05 ~ '*',
            TRUE ~ NA_character_
          ),
          y = 0
        ),
        position = position_dodge2(width = .9),
        show.legend = FALSE
      ) +
      guides(fill=guide_legend(title="Target\nValence")) +
      theme(
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),
        panel.spacing = margin(.5,1.5,.5,0,unit="cm"),
        plot.margin = margin(.75,0,.75,0,unit="cm"),
        axis.title.y = element_text(vjust = 1,angle=0),
        title = element_text(hjust=.8)
      )
  ) %$%
  plot_grid(
    plot_grid(
      plots[[1]] + theme(legend.position="none"),
      plots[[3]] + theme(legend.position="none"),
      plots[[4]] + theme(legend.position="none"),
      plots[[2]] + theme(legend.position="none"),
      plots[[5]] + theme(legend.position="none"),
      plots[[6]] + theme(legend.position="none"),
      nrow=2
      ),
    get_legend(plots[[1]] + theme(legend.margin=margin(0,0,1.5,.5,unit="cm"))),
    nrow=1,
    rel_widths = c(1,.25)
  )

```



##################
## Something Else ...
##################



```{r label, options}

ambOther %>% emmeans("otherValence2") %>% contrast(method="revpairwise")

ambUni %>% summary %$% coefficients %>% as.data.frame %>%
  rownames_to_column %>% as_tibble


ambUniOther %>% emmeans(~otherValence2+Pos*Neg) %>% contrast

ambUni %>% emmip(Pos~Neg, cov.reduce = range)


ambPosOther %>% emmip(otherValence2~Pos,cov.reduce=range)

ambNegOther %>% emmip(otherValence2~Neg,cov.reduce=range)

ambUniOther %>% emmip(Pos~Neg|otherValence2, cov.reduce = range)

```

```{r plot, options}

df_val %>%
  ggplot(aes(y=valDir,x=otherValence2)) +
  geom_jitter(alpha=.3)+
  facet_grid(otherDir ~ catSRI) +
  theme_bw()

df_val %>%
  ggplot(aes(y=valDir,x=otherValence2)) +
  geom_jitter(alpha=.3)+
  facet_grid(otherDir ~ catSRI_ext) +
  theme_bw()

```

```{r SRI by Direct, options}

# What about centering (of Amb, Neg, Pos) here? Especially as we forego Subject

# Is there a good reason to use nnet::multinom() here?

catSRIFit <- df_val %>% spread(otherDir,valDir) %>%
  distinct(Subject,otherValence,otherValence2,Pos,Neg,Amb,catSRI,catSRI_ext) %>%
  mutate(
    catSRI=factor(catSRI,levels=c('supportive','indifferent','ambivalent','aversive'))
    ) %>%
  nnet::multinom(
    catSRI ~ otherValence2 + Amb + Neg + Pos,
    data=.,
    contrasts = "contr.poly"
  )

catSRI_extFit <- df_val %>% spread(otherDir,valDir) %>%
  distinct(Subject,otherValence,otherValence2,Pos,Neg,Amb,catSRI,catSRI_ext) %>%
  mutate(
    catSRI_ext=factor(catSRI_ext,levels=c('supportive','indifferent','ambivalent','aversive'))
    ) %>%
  nnet::multinom(
    catSRI_ext ~ otherValence2 + Amb + Neg + Pos,
    data=.,
    contrasts = "contr.poly"
  )

```


