---
Author: Thomas Verliefde
Date: '2019-03-05'
Output: html_document
Title: Analyses RelAmb
editor_options:
  chunk_output_type: console
version: '1.1'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```

```{r libraries, include=FALSE}
lapply(
  c("plyr","dplyr","tidyr","ggplot2","readxl","readr","lme4","afex","lmerTest","emmeans",
    "pbkrtest","purrr","magrittr","cowplot"),
  require,
  character.only = T
)
```

#############################
# Importing & Cleaning Data #
#############################

Make sure the relevant datafiles (Data_RelAmb.zip and BAWL-R.xls) are in the working directory.

```{r BAWL-R.xls, options}

bawl <- "BAWL-R.xls" %>% read_excel %>%
  mutate(
    WORD_CLASS = recode(
      WORD_CLASS,
      "N" = "NOUN",
      "V" = "VERB",
      "A" = "ADJ"
    )
  )


```

```{r Data_RelAmb.zip, include=FALSE}

temp <- tempdir()
df_raw <- "Data_RelAmb.zip" %>% {
  ldply(
    .data = unzip(.,list=T) %>% # unzip the 
      filter(grepl("(.csv)$",.$Name)) %>% # Ignore any file/folder that is not a .csv file
      arrange(Name %>% desc) %$% Name, # Returns a 'list' containing the relevant .csv filenames
    .fun = function(x) unzip(.,files=x,exdir=temp) %>% read_csv
  )
}
rm(temp)

```


```{r label, options}

# temp <- tempdir()
# df_test <- "Data_RelAmb.zip" %>% 
#   unzip(.,files=unzip(.,list=T) %>% filter(grepl("(.csv)$",.$Name)) %>% extract(1,1), exdir=temp) %>%
#   read_csv
# rm(temp)
# 
# df_test %>% glimpse
# unzip("Data_RelAmb.zip",list=T) %>% filter(grepl("(.csv)$",.$Name)) %>% extract(1,1)

```

```{r Data_RelAmb.zip, include=FALSE}

temp <- tempdir()
df_rawTime <- "Data_RelAmb.zip" %>% {
  ldply(
    .data = unzip(.,list=T) %>% # unzip the 
      filter(grepl("(.csv)$",.$Name)) %>% # Ignore any file/folder that is not a .csv file
      arrange(Name %>% desc) %$% Name, # Returns a 'list' containing the relevant .csv filenames
    .fun = function(x) unzip(.,files=x,exdir=temp) %>%
      read_csv(col_names=FALSE,skip=1) %>% select(1,(dim(.)[2]-12):dim(.)[2])
  ) %>% select(sort(current_vars())) %>% {
    bind_cols(
      filter(.,X756 %>% is.na) %>% select(-X756) %>% t %>% as_tibble,
      filter(.,X769 %>% is.na) %>% select(-X769) %>% t %>% as_tibble
    ) } %>% t %>% as_tibble %>% select(-14) %>% mutate_at(vars(-1),as.numeric) %>%
      mutate_at(vars(-1),function(x) format(x,scientific=FALSE)) %>%
    mutate_at(vars(seq(3,13,2)), function(x) gsub("( *)(\\d+)",".\\2",x)) %>%
    mutate_all(as.numeric) %$% 
      bind_cols(
        select(.,V1),
        list(extract(.,seq(2,12,2)),extract(.,seq(3,13,2))) %>% pmap(add) %>% as_tibble
      ) %>%
    rename(
      Subject = V1,
      timeOther = V2,
      timePractice = V4,
      timeExperiment = V6,
      timeExplicit = V8,
      timeDemographics = V10,
      timeTotal = V12
    )
}
rm(temp)

```



This part cleans the data up a lot, and puts it in an useable long format.

A few variables are dropped, as they are not crucial for the current investigations.
The data for each trial (both practice and experiment) is put in long format.
The data for each significant other is put in long format.
The information about block(practice/experiment), trialnr, and descriptives (Answer,Prime, primeType, Target, targetType, RT).
Descriptives is spread out again, to have columns for each.
Some variables are renamed.
Some variables are mutated:
  Many are transformed to strings or numericals
  primeType & targetType get clear non-numerical labels
  primeValence is created to reflect the valence of the primes (regardless of nouns or others)
  Condition shows congruent or incongruent trials (or base, for neutral stimuli)
  Correct indicates whether the target was correctly classified
  Inclusion sets whether or not the trial should be included
    Note: we should still implement exclusion of low acc participants # tried implementing, not yet ready
  LogRT is a simple transformation of RT to it's natural logarithm.

```{r cleaning & gathering, options}

df <- df_raw %>% 
  select(
    -c(practicePrimes,practiceTrials,experimentPrimes,experimentTrials,timeOther:dim(.)[2])
  ) %>%
  gather(
    "fullTrials",
    "trialsOutput",
    matches("^([a-z])+_(\\d)+_([a-z])+$") # This regex matches things with structure: abcd*_123*_abcd*
  ) %>%
  gather(
    "fullOthers",
    "otherOutput",
    matches("^(other)(Pos|Neg)(1|2)") # This regex matches: otherPos1*, otherPos2*¨, otherNeg1*, or otherNeg2*
  ) %>%
  separate(
    fullTrials,
    c("Block","Trial","Desc"),
    sep = "_"
  ) %>%
  spread(
    key = Desc, value = trialsOutput
  ) %>%
  separate(
    fullOthers,
    c("otherValence","Desc"),
    sep = "_",
    extra = "merge",
    fill = "right"
  ) %>%
  mutate(
    Desc = Desc %>% replace_na("otherNames") # alternatively, we could use coalesce.
  ) %>%
  spread(
    key = Desc, value = otherOutput
  ) %>%
  gather(
    "otherDir",
    "valDir",
    matches("^(Dir_)")
  ) %>%
  gather(
    "otherSRI",
    "valSRI",
    matches("^(SRI_)")
  ) %>%
  mutate_at(
    vars(otherDir,otherSRI),
    funs(gsub("(^.{4})|(\\d)","",.))
  ) %>%
  separate(
    otherSRI,
    c("SRIValence"),
    sep = "_",
    extra = "drop",
    remove=FALSE
  ) %>%
  rename(
    Answer = answer,
    Prime = prime,
    primeType = primeCat,
    Target = target,
    targetType = targetCat,
    otherNum = Num,
    otherRel = Rel,
    RT = time
  ) %>%
  mutate_at(
    vars(Subject,Trial,RT,Age,otherNum,valDir,valSRI),
    as.numeric
  ) %>%
  # filter(Block == "experiment") %>% # drop all practice trials
  group_by(Subject,Block) %>%
  mutate(
    Gender = recode(
      Gender,
      "männlich" = "male",
      "weiblich" = "female"
    ),
    Language = recode(
      Language,
      "Deutsch" = "germanLang",
      "Sonstiges" = "otherLang"
    ),
    Handedness = recode(
      Handedness,
      "rechts" = "rightHand",
      "links" = "leftHand",
      "beide" = "bothHands"
    ),
    primeType = recode(
      primeType,
      `0`= "nounPos",
      `1`= "nounNeg",
      `2`= "otherPos",
      `3`= "otherNeg",
      `4`= "letterStr"
    ) %>% as.factor,
    targetType = recode(
      targetType,
      `0` = "adjPos",
      `1` = "adjNeg"
    ),
    primeValence = case_when(
      grepl("Pos$",primeType) ~ "Pos",
      grepl("Neg$",primeType) ~ "Neg",
      TRUE ~ "Base"
    ) %>% as.factor,
    primeSource = gsub("^(noun|other|letter)(Pos|Neg|Str)$","\\1",primeType) %>% as.factor,
    otherValence = gsub("^(other)(Pos|Neg)(\\d)$","\\2",otherValence),
    Condition = case_when(
      primeValence == "Pos" & targetType == "adjPos" ~ "Congruent",
      primeValence == "Neg" & targetType == "adjNeg" ~ "Congruent",
      primeValence == "Base" ~ "Base",
      TRUE ~ "Incongruent"
    ) %>% as.factor,
    Condition2 = interaction(
      primeSource,Condition,drop=TRUE,sep="",lex.order=TRUE
    ),
    lagPrime = case_when(
      lag(primeType) == primeType~ "Congruent",
      TRUE ~ "Incongruent"),
    lagSource = case_when(
      lag(primeSource) == primeSource~ "Congruent",
      TRUE ~ "Incongruent"),
    lagValence = case_when(
      lag(primeValence) == primeValence~ "Congruent",
      TRUE ~ "Incongruent"),
    lagCondition = case_when(
      lag(Condition) == Condition ~ "Congruent",
      TRUE ~ "Incongruent"),
    Correct = case_when(
      Key == "Apos" & targetType == "adjPos" & Answer == "A" ~ TRUE,
      Key == "Apos" & targetType == "adjNeg" & Answer == "L" ~ TRUE,
      Key == "Aneg" & targetType == "adjNeg" & Answer == "A" ~ TRUE,
      Key == "Aneg" & targetType == "adjPos" & Answer == "L" ~ TRUE,
      TRUE ~ FALSE),
    Accuracy = mean(Correct), # Because we grouped by subject, these means are computed by subject
    speedInclusion = (RT >= 300 & RT <= 3000), # Trials with latencies < 300 and > 3000 were excluded
    accInclusion = (1 - mean(speedInclusion)) < 0.83,
      # If we have to exclude more than 83% of the trials of a single participant,
      #  then this participant will be excluded entirely.
    nameExclusion = (Subject == 8 | Subject == 72),
    # These two participants did not follow instructions, as they did not provide sufficient 
    #  and actual names for SOs as they were instructed to do.
    # Specifically, one participant provided us with 'Niemanden' (nobody in German),
    #  the other participant provided weird nicknames, not proper names.
    subjExclusion = not(accInclusion) | nameExclusion,
    Exclusion = not(speedInclusion) & not(accInclusion) & nameExclusion,
    Inclusion = Correct & not(Exclusion),
    logRT = log(RT)
  ) %>%
  ungroup %>%
  arrange(Subject)

```

This part creates a few subdataframes, to keep overview and reduce the amount of replicated rows.
[almost 83000 rows for the full dataset with only 2 participants, due to multiple "gatherings"]

```{r Specific Dataframes, options}

df_subj <- df %>% filter(Block == "experiment") %>%
  select(
    Subject,Age,Gender,Language,Handedness,Accuracy,subjExclusion,accInclusion,Study,Key,FirstOthers
  ) %>% distinct %>% arrange(Subject)

df_others <- df %>% filter(Block == "experiment") %>%
  select(
    Subject,Gender,otherValence,otherNames,otherRel,otherNum,otherDir,
    valDir,SRIValence,otherSRI,subjExclusion,Study,Key,FirstOthers
  ) %>% distinct %>% arrange(Subject)

df_time <- df %>% filter(Block == "experiment") %>%
  select(
    Subject,Gender,subjExclusion,accInclusion,Accuracy
  ) %>% distinct %>% arrange(Subject) %>%
  full_join(df_rawTime,by="Subject")

df_trials <- df %>% filter(Block == "experiment") %>%
  select(
    Subject,Trial,RT,logRT,Prime,primeType,primeSource,primeValence,Target,targetType,
    Condition,Condition2,Answer,Correct,speedInclusion,accInclusion,subjExclusion,
    nameExclusion,Inclusion,Accuracy,Gender,Key,FirstOthers,Handedness
  ) %>% distinct %>% arrange(Subject,Trial)

df_base <- df_raw %>% select(c(practicePrimes,experimentPrimes))

```


#######################
# Demographics & More #
#######################

```{r Inclusions, options}

df_trials %>% group_by(Subject) %>% summarize(
  "excl" = Correct %>% not %>% mean(na.rm=T)
) %$% mean(excl) %>% multiply_by(100) %>% signif(5) %>%
  paste0(.,"% of trials were excluded because they were incorrectly categorized.")

df_trials %>% group_by(Subject) %>% summarize(
  "excl" = speedInclusion %>% not %>% mean(na.rm=T)
) %$% mean(excl) %>% multiply_by(100) %>% signif(5) %>%
  paste0(.,"% of trials were excluded because the response latencies were either too short (<300ms), or too long (>3000ms)") %>%
  cat

df_subj %$% sum(accInclusion %>% not) %>%
  paste("A total of",.,"participants were fully excluded due to extremes in accuracy and/or latency.") %>%
  cat

df_subj %$% sum(subjExclusion) %>%
  paste("A total of",.,"participants were fully excluded due to not following instructions.") %>%
  cat

df_trials %>% filter(!subjExclusion) %>% group_by(Subject) %>% summarize("trialInclusion" = Inclusion %>% mean) %>%
  summarize(trialInclusion %>% mean) %>% as.numeric %>% multiply_by(100) %>% signif(5) %>%
  paste0("In total, ",.,"% of all trials from included participants were included.") %>%
  cat

```

```{r Gender; Language; & Handedness, options}

df_subj %>% filter(accInclusion & !subjExclusion) %>% {
  bind_rows(
    count(., "Var" = "Total"),
    count(., "Var" = Gender),
    count(., "Var" = Language),
    count(., "Var" = Handedness)
  )
} %>% mutate(
  "%" = extract2(.,1,"n") %>%
    divide_by(n,.) %>%
    multiply_by(100) %>%
    signif(4)
)

```

```{r Age & Accuracy, options}

df_subj %>% filter(accInclusion & !subjExclusion) %>% 
  summarize_at(
    vars(Age,Accuracy),
    funs(mean,sd,min,max,median,.args = list(na.rm=T))
  ) %>% gather("Var","Value") %>%
  separate(Var,c("Var","Func"),sep="_") %>%
  spread(Func,Value) %>% select(Var,mean,sd,min,max,median) %>% as.data.frame

```

```{r Control Variables, options}

df_subj %>% filter(accInclusion & !subjExclusion) %>% count(Key,FirstOthers) %>%
  mutate("%" = n %>% divide_by(sum(.)) %>% multiply_by(100))

```

```{r Specific Timings Experiment Duration, options}

df_time %>% filter(accInclusion & !subjExclusion) %>%
  summarize_at(
    vars(starts_with("time")),
    funs(mean,sd,min,max,.args=list(na.rm=T))
  ) %>% gather("Var","Value") %>%
  separate(Var,c("Var","Func"),sep="_") %>%
  spread(Func,Value) %>% select(Var,mean,sd,min,max) %>%
  slice(c(4,5,2,3,1,6)) %>% as.data.frame

```

```{r legacy code, eval=FALSE, include=FALSE}

# This code is only here because I am really proud of it, at least the sapply within select.
# It is utterly outdated

# df %>% mutate(pointTime = gsub("^(.*)$","time\\1",pointTime)) %>%
#   distinct(Subject,pointTime,valTime,subjInclusion) %>%
#   spread(pointTime,valTime) %>%
#   filter(Subject %>% duplicated %>% not & subjInclusion) %>%
#   summarize_at(
#     vars(matches("^time")),
#     funs(mean,sd,min,max,.args=list(na.rm=T))
#   ) %>% select(
#     sapply(
#       c("Other","Practice","Experiment","Explicit","Demographics","Total"),
#       matches
#     ) # I am actually suprised that this works...
#   ) %>% gather("Var","Value") %>% separate(Var,c("Var","Func"),sep="_") %>%
#   spread(Func,Value) %>% select(Var,mean,sd,min,max)

```

######################
# Significant Others #
######################


```{r Names, options}

df_others %>% group_by(otherNames,Subject) %>%
  summarize("otherNum" = otherNum %>% mean(na.rm=T)) %>%
  summarize("n" = n(),"otherNum" = otherNum %>% mean(na.rm=T)) %>%
  add_count(n) %>% arrange(nn %>% desc)

df_others %>% group_by(otherNames,Subject) %>% filter(!is.na(otherNum)) %>%
  summarize(
    "otherNum" = otherNum %>% mean(na.rm=T),
    "otherMax" = otherNum %>% max()
    ) %>% summarize_at(vars(otherNum,otherMax),funs(mean,max,.args=list(na.rm=T)))
  summarize("n" = n(), "otherNum" = otherNum %>% mean(na.rm=T)) %>%
  

```

```{r Repeated Names between Participants, options}

# The following code shows a list of all names used by our included participants
#View(df_others %>% filter(subjExclusion) %>% distinct(otherNames) %>% arrange(otherNames))

df_others %>% distinct(otherNames,Subject) %>% count(otherNames) %>% count(n)

df_others %>% distinct(otherNames,Subject) %>% count(otherNames) %>% filter(n > 1) %>% arrange(desc(n))

```

Comments, by checking all the names, there are a few issues:

Clearly not names:
Derkleine, Derwächter, Niemanden

Probably family names, instead of first names:
Schindler, Stepputtis, Waltraut, Kopp

```{r label, options}

df_others %>%
  filter(otherNames %in% c("Derkleine","Derwächter","Niemanden","Schindler","Stepputtis","Waltraut","Kopp")) %>%
  distinct(Subject,otherNames,otherRel)

```

The participants who provided the three items that are clearly not names were excluded.


```{r Relations, options}

# df %>% group_by(otherRel,otherNames,Subject) %>%
#   summarize %>% ungroup %>% count("Relation_Type" = otherRel)

df_others %>% distinct(Subject,otherRel) %>%
  count(otherRel) %T>% View

df_others %>%
  filter(otherRel %in% c("Schmarotzer","KrankerTeufel")) %>%
  distinct(Subject,otherNames,otherRel)

```

The two items clearly not relational descriptions ("Schmarotzer" and "KrankerTeufel", German swearwords) belong to the participant who also provided non-name items, and as such already is excluded.

#########################
## Differences Pos/Neg ##
#########################

```{r otherValence, options}



```

```{r SRI, options}

```




#################
# Main Analyses #
#################

```{r Control, options}

df_trials %>% count(Subject) %$% unique(n) %>%
  paste("Each subject viewed a total of",.,"trials.")

df_trials %>% filter(Subject == 1) %>% count(primeType)

df_trials %>% filter(Subject == 1) %>% count(targetType)

df_trials %>% filter(Subject == 1) %>% count(primeType,targetType)

```

```{r label, options}

df_trials %>% filter(Inclusion) %>% count(primeType,targetType,Subject) %>% count(n)

```




```{r model with only random intercept for subject, cache=TRUE}
# emmeans::emm_options(pbkrtest.limit=8000,lmerTest.limit=8000) # Trying it here
afex::set_effects_contrasts()
fitAfex <- df_trials %>% filter(Inclusion) %>% {
  mixed(
    logRT ~ primeType * targetType + (1|Target) + (1|Subject),
    data=., method = "KR",
    check_contrasts = TRUE,
    expand_re=FALSE
  )
}

fitAfex

summary(fitAfex) %$% coefficients %>% zapsmall #Neat function that puts very small numbers to 0

emmeans(fitAfex,"targetType") %>% contrast(method="revpairwise")
primeContr <- emmeans(fitAfex,"primeType") %>% contrast(method="revpairwise")
plannedMeans <- emmeans(fitAfex,~primeType*targetType)

plannedContr <- fitAfex %>% emmeans(c("primeType","targetType")) %>%
  contrast(method="revpairwise") %>% as_tibble %>%
  separate(contrast,c("contrastA","contrastB"),sep=" - ") %>%
  separate(contrastA,c("cPrimeA","cTargetA"),sep=",") %>%
  separate(contrastB,c("cPrimeB","cTargetB"),sep=",") %>%
  filter(
    ((cPrimeB == "letterStr" & (cPrimeA == "otherNeg" | cPrimeA == "otherPos")) |
    (cPrimeB == "nounNeg" & cPrimeA == "otherNeg") |
    (cPrimeB == "nounPos" & cPrimeA == "otherPos")) & cTargetA == cTargetB
  ) %>% arrange(cPrimeB,cPrimeA,cTargetA)

fullContr <- fitAfex %>% emmeans(c("primeType","targetType")) %>%
  contrast(method="revpairwise") %>% as_tibble %>%
  separate(contrast,c("contrastA","contrastB"),sep=" - ") %>%
  separate(contrastA,c("cPrimeA","cTargetA"),sep=",") %>%
  separate(contrastB,c("cPrimeB","cTargetB"),sep=",") %>%
  arrange(cPrimeB,cPrimeA,cTargetA)

primeContr <- fitAfex %>% emmeans("primeType") %>%
  contrast(method="revpairwise") %>% as_tibble %>%
  separate(contrast,c("contrastA","contrastB"),sep=" - ") %>%
  arrange(contrastA,contrastB)


```

```{r label, options}

plannedContr

fullContr %>%
  filter(cPrimeA==cPrimeB) 

fullContr %>%
  filter((cPrimeA == "otherPos" & cPrimeB == "nounNeg" & cTargetA == "adjNeg" & cTargetB == "adjNeg") | (
    cPrimeA == "otherNeg" & cPrimeB == "nounPos" & cTargetA == "adjPos" & cTargetB == "adjPos"))

primeContr

```





```{r Multilevel Models, options}

# df_trials %>% filter(Inclusion) %>% {
#   fitNull <<- lmer(
#     logRT ~ 1 + (1|Target) + (Condition2|Subject), data=., REML = TRUE
#   )
#   # fitType <<- lmer(
#   #   logRT ~ primeType * Condition + (1|Subject), data=., REML=TRUE
#   # )
#   fitJudd <<- lmer(
#     logRT ~ Condition2 + (1|Target) + (Condition2|Subject), data=., REML=TRUE
#   )
#   # fitSource <<- lmer(
#   #   logRT ~ primeSource * Condition + (1|Subject), data=., REML=TRUE
#   # )
# }
# 
# summary(fitJudd)
# KRmodcomp(fitJudd, fitNull) # for Kenward-Roger approximate F-test

```


```{r Afex, options}
# 
# df_trials %>% filter(Inclusion) %>% {
#   fitAfex <<- mixed(
#     logRT ~ primeType + (1|Target) + (primeType|Subject), data=., method="KR",
#     check_contrasts=FALSE)
# }
# 
# anova(fitAfex)
# summary(fitAfex)
```

```{r Model with random slope for subject, cache=TRUE}
# emmeans::emm_options(pbkrtest.limit=8000,lmerTest.limit=8000) #Cannot allocate vector of size 383.8 Mb
# afex::set_effects_contrasts()
# fitAfex1 <- df_trials %>% filter(Inclusion) %>% {
#   mixed(
#     logRT ~ primeType * targetType + (1|Target) + (primeType*targetType||Subject),
#     data=., method = "KR",
#     check_contrasts = TRUE,
#     expand_re=TRUE
#   )
# }
# 
# fitAfex1
# summary(fitAfex1) %$% coefficients %>% zapsmall #Neat function that puts very small numbers to 0
# 
# emmeans(fitAfex1,"targetType") 
# emmeans(fitAfex1,"primeType")
# emmeans(fitAfex1,~primeType*targetType)
# 
# plannedContr1 <- fitAfex1 %>% emmeans(c("primeType","targetType")) %>%
#   contrast(method="revpairwise") %>% as_tibble %>%
#   separate(contrast,c("contrastA","contrastB"),sep=" - ") %>%
#   separate(contrastA,c("cPrimeA","cTargetA"),sep=",") %>%
#   separate(contrastB,c("cPrimeB","cTargetB"),sep=",") %>%
#   filter(
#     ((cPrimeB == "letterStr" & (cPrimeA == "otherNeg" | cPrimeA == "otherPos")) |
#     (cPrimeB == "nounNeg" & cPrimeA == "otherNeg") |
#     (cPrimeB == "nounPos" & cPrimeA == "otherPos")) & cTargetA == cTargetB
#   ) %>% arrange(cPrimeB,cPrimeA,cTargetA)
# 
# plannedContr1

```



```{r model without random intercept target, only random intercept Subject, cache=TRUE}
# emmeans::emm_options(pbkrtest.limit=8000,lmerTest.limit=8000) # Trying it here
# afex::set_effects_contrasts()
# fitAfex3 <- df_trials %>% filter(Inclusion) %>% {
#   mixed(
#     logRT ~ primeType * targetType + (1|Subject),
#     data=., method = "KR",
#     check_contrasts = TRUE,
#     expand_re=TRUE
#   )
# }
# 
# fitAfex3
# summary(fitAfex3) %$% coefficients %>% zapsmall #Neat function that puts very small numbers to 0
# 
# emmeans(fitAfex3,"targetType") 
# emmeans(fitAfex3,"primeType")
# emmeans(fitAfex3,~primeType*targetType)
# 
# plannedContr3 <- fitAfex3 %>% emmeans(c("primeType","targetType")) %>%
#   contrast(method="revpairwise") %>% as_tibble %>%
#   separate(contrast,c("contrastA","contrastB"),sep=" - ") %>%
#   separate(contrastA,c("cPrimeA","cTargetA"),sep=",") %>%
#   separate(contrastB,c("cPrimeB","cTargetB"),sep=",") %>%
#   filter(
#     ((cPrimeB == "letterStr" & (cPrimeA == "otherNeg" | cPrimeA == "otherPos")) |
#     (cPrimeB == "nounNeg" & cPrimeA == "otherNeg") |
#     (cPrimeB == "nounPos" & cPrimeA == "otherPos")) & cTargetA == cTargetB
#   ) %>% arrange(cPrimeB,cPrimeA,cTargetA)
# 
# plannedContr3

```

############
## Graphs ##
############

```{r label, options}

plannedContr2 %>%
  group_by(cPrimeA,cPrimeB) %>%
  do(
    plots = ggplot(.,aes(x=cPrimeA,y=estimate,fill=cTargetA)) +
      geom_col(position="dodge") + ggtitle(paste0(.$cPrimeA,"-",.$cPrimeB)) +
      labs(x="",y="") +
      scale_x_discrete(labels=NULL,breaks=NULL) +
      scale_y_continuous(breaks=seq(-0.06,.12,.02) ,limits=c(-0.03,.13)) +
      geom_label(aes(label=p.value %>% sprintf("%.4f",.)),position = position_dodge(width=.9))+
      theme(legend.position="none")
  ) %$% 
  plot_grid(
    plot_grid(plotlist=plots,align="hv"),
    get_legend(ggplot(plannedContr2,aes(x=cPrimeA,y=estimate,fill=cTargetA))+geom_col()),
    rel_widths = c(3,.5)
  )
```

```{r label, options}

plannedMeans2 %>% as_tibble %>%
  ggplot(aes(x=primeType,y=emmean,fill=targetType)) +
  geom_col(position="dodge") +
  coord_cartesian(ylim=c(6.45,6.7))



```

########################
# Exploratory Analyses #
########################